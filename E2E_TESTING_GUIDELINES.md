# E2E Testing Guidelines

## Overview

This document defines the end-to-end (e2e) testing strategy for SimCiv. E2E tests represent complete user journeys through the software that can be verified both programmatically and visually by comparing screenshots to descriptions of expected behavior.

## Philosophy

E2E tests serve two primary purposes:

1. **Automated Verification**: Tests programmatically verify that the UI state, DOM elements, and application state match expectations
2. **Visual Documentation**: Screenshots provide a visual narrative of user workflows that can be manually reviewed for styling and visual effects

**Critical Principle**: E2E tests must catch actual bugs through programmatic assertions. Screenshots are for visual approval of styling changes only - not for finding functional bugs.

## Folder Structure

Each e2e test represents a numbered user journey and follows this structure:

```
e2e/
â”œâ”€â”€ 000-user-registration/
â”‚   â”œâ”€â”€ test.spec.ts          # Test code
â”‚   â”œâ”€â”€ screenshots/           # Generated screenshots
â”‚   â”‚   â”œâ”€â”€ 000-initial-load.png
â”‚   â”‚   â”œâ”€â”€ 001-username-entered.png
â”‚   â”‚   â””â”€â”€ 002-registration-complete.png
â”‚   â””â”€â”€ README.md             # Auto-generated documentation
â”œâ”€â”€ 001-game-creation/
â”‚   â”œâ”€â”€ test.spec.ts
â”‚   â”œâ”€â”€ screenshots/
â”‚   â””â”€â”€ README.md
â””â”€â”€ helpers/                   # Shared test utilities
    â”œâ”€â”€ auth.ts
    â”œâ”€â”€ screenshot.ts
    â””â”€â”€ ...
```

### Naming Conventions

- **Test folders**: `NNN-descriptive-name/` where NNN is a zero-padded number (000, 001, 002, ...)
- **Test files**: `test.spec.ts` (consistent name in each folder)
- **Screenshots**: `NNN-descriptive-step.png` within the `screenshots/` subdirectory
- **Documentation**: `README.md` auto-generated in each test folder

Example test names:
- `000-user-registration` - New user registration flow
- `001-user-login` - Existing user login flow  
- `002-game-creation` - Creating a new game
- `003-game-lobby` - Joining and viewing game lobby
- `004-map-exploration` - Map navigation and interaction

## Screenshot Requirements

### Generation

Screenshots are **automatically generated** when running e2e tests. The test code is responsible for:

1. Taking screenshots at each significant step in the user journey
2. Generating the README.md file documenting each screenshot
3. Storing screenshots in the `screenshots/` subdirectory

### Naming and Numbering

Screenshots within a test folder are numbered sequentially:

```
000-initial-load.png          # First step
001-form-filled.png           # Second step
002-validation-error.png      # Third step
003-success-message.png       # Fourth step
```

The numbering:
- Starts at 000 within each test folder
- Increments by 1 for each step
- Uses zero-padded three-digit numbers (000-999)
- Includes a descriptive name after the number

### README.md Auto-Generation

Each test folder's `README.md` must be auto-generated by the test code and include:

```markdown
# Test: User Registration

## Overview
This test verifies the complete user registration flow from initial page load through successful account creation.

## Screenshots

### 000-initial-load.png
![000-initial-load.png](screenshots/000-initial-load.png)

**Programmatic Verification:**
- âœ“ Page title is "SimCiv Authentication"
- âœ“ Registration form is visible
- âœ“ All required form fields are present

**Manual Visual Verification:**
- Verify form styling and layout
- Check button colors and hover states
- Confirm responsive design at viewport size

### 001-form-filled.png
![001-form-filled.png](screenshots/001-form-filled.png)

**Programmatic Verification:**
- âœ“ Username field contains "testuser"
- âœ“ Password fields are masked
- âœ“ Submit button is enabled

**Manual Visual Verification:**
- Verify input field styling
- Check form validation indicators
- Confirm error message styling (if applicable)

### 002-registration-complete.png
![002-registration-complete.png](screenshots/002-registration-complete.png)

**Programmatic Verification:**
- âœ“ Success message is displayed
- âœ“ User is redirected to game lobby
- âœ“ User's alias is shown in the UI

**Manual Visual Verification:**
- Verify success message styling
- Check authenticated user UI layout
- Confirm navigation elements are visible
```

The README must clearly separate:
1. **Programmatic Verification**: What the test code actually checks
2. **Manual Visual Verification**: What a human reviewer should verify in the screenshot

Screenshots are directly linked using markdown image syntax for easy viewing.

## Programmatic Verification Requirements

**Every e2e test MUST verify the following programmatically:**

### 1. Application State

For Svelte applications, verify reactive state variables:

```typescript
// Check authentication state
await expect(page.locator('.authenticated')).toBeVisible();

// Verify user data is loaded
const username = await page.locator('.user-info h2').textContent();
expect(username).toBe('testuser');
```

### 2. DOM Elements

Verify that expected elements exist and have correct content:

```typescript
// Element exists and is visible
await expect(page.locator('h1')).toBeVisible();
await expect(page.locator('h1')).toContainText('Expected Title');

// Element has correct attributes
await expect(page.locator('button')).toBeEnabled();
await expect(page.locator('input[type="password"]')).toHaveAttribute('type', 'password');

// Element count
await expect(page.locator('.game-card')).toHaveCount(3);
```

### 3. UI State and Behavior

Verify interactive elements behave correctly:

```typescript
// Forms
await page.fill('input#username', 'testuser');
const value = await page.inputValue('input#username');
expect(value).toBe('testuser');

// Buttons and clicks
await page.click('button:has-text("Submit")');
await expect(page.locator('.success-message')).toBeVisible();

// Navigation
await expect(page).toHaveURL(/\/game\/123/);

// Conditionally visible elements
await expect(page.locator('.error-message')).not.toBeVisible();
await expect(page.locator('.loading-spinner')).toBeHidden();
```

### 4. Data Rendering

Verify that data from the backend is correctly rendered:

```typescript
// Game list rendering
const gameCards = page.locator('.game-card');
await expect(gameCards).toHaveCount(2);

const firstGame = gameCards.first();
await expect(firstGame.locator('.game-id')).toContainText('Game #1');
await expect(firstGame.locator('.game-state')).toContainText('Waiting');
await expect(firstGame.locator('.player-count')).toContainText('1/2');
```

### 5. Application Logic

Verify business logic executes correctly:

```typescript
// Game state transitions
await page.click('button:has-text("Start Game")');
await expect(page.locator('.game-state')).toContainText('In Progress');

// Time progression
const initialTime = await page.locator('.game-time').textContent();
await page.click('button:has-text("Advance Time")');
const newTime = await page.locator('.game-time').textContent();
expect(newTime).not.toBe(initialTime);
```

## Pixel-Perfect Screenshot Expectations

Screenshots must be **pixel-for-pixel identical** between test runs. This is enforced through:

### 1. Hash-Based Comparison

The `screenshotIfChanged()` helper compares SHA-256 hashes of screenshots:

```typescript
import { screenshotIfChanged } from '../helpers/screenshot';

// Take screenshot and verify it matches expected
await screenshotIfChanged(page, { 
  path: 'e2e/000-user-registration/screenshots/000-initial-load.png',
  fullPage: true 
});
```

**Behavior:**
- âœ… **Pass**: Screenshot hash matches expected â†’ Test passes
- âŒ **Fail**: Screenshot hash differs â†’ Test fails with clear error message
- ðŸ“¸ **Create**: Screenshot doesn't exist â†’ Creates it (first run only)

### 2. Deterministic Test Environment

To ensure pixel-perfect reproducibility:

#### Timestamp Stabilization
```typescript
import { mockDateInBrowser } from '../helpers/mock-time';

test.beforeEach(async ({ page }) => {
  await mockDateInBrowser(page);
});
```

This ensures all timestamps display the same value: `"1/1/2024, 12:00:00 PM"`

#### Deterministic Data
- Use `resetUuidCounter()` for predictable UUIDs
- Use `enableE2ETestMode()` to enable test-specific behaviors
- Clear database before each test for consistent starting state

#### Stable Rendering
```typescript
// Wait for page to fully stabilize
await page.waitForLoadState('networkidle');

// Wait for fonts to load
await page.waitForLoadState('domcontentloaded');

// Wait for specific element to be stable
await expect(page.locator('.game-lobby')).toBeVisible();
```

### 3. Screenshot Update Workflow

When UI changes are made:

```bash
# Run tests - they will fail due to screenshot mismatch
npm run test:e2e

# Review the changed screenshots
# If changes are correct and intentional:
UPDATE_SCREENSHOTS=1 npm run test:e2e

# Verify tests pass with new screenshots
npm run test:e2e

# Commit new screenshots
git add e2e/*/screenshots/
git commit -m "Update screenshots for UI changes"
```

## Timing and Waiting Policy

**CRITICAL RULE: Tests MUST NOT use arbitrary delays.**

### âŒ PROHIBITED: waitForTimeout

```typescript
// âŒ ILLEGAL - Never use arbitrary timeouts
await page.waitForTimeout(1000);
await page.waitForTimeout(500);

// âŒ ILLEGAL - Even short timeouts are not allowed
await page.waitForTimeout(100);
```

**Rationale**: Arbitrary delays make tests:
- Non-deterministic and flaky
- Slower than necessary
- Unable to detect actual timing bugs
- Mask race conditions

### âœ… ALLOWED: Event-Based Waiting

Wait for actual conditions to be met:

```typescript
// âœ… Wait for element to be visible
await expect(page.locator('.success-message')).toBeVisible();

// âœ… Wait for element to have text
await expect(page.locator('.status')).toContainText('Ready');

// âœ… Wait for URL change
await page.waitForURL(/\/game\/\d+/);

// âœ… Wait for network to be idle
await page.waitForLoadState('networkidle');

// âœ… Wait for DOM to be loaded
await page.waitForLoadState('domcontentloaded');

// âœ… Wait for element to be ready for interaction
await page.waitForSelector('.button:not([disabled])');

// âœ… Wait for specific state change
await page.waitForFunction(() => {
  const element = document.querySelector('.counter');
  return element && element.textContent === '10';
});
```

### âœ… ALLOWED: Single Animation Frame

When you need to wait for a single render cycle:

```typescript
// âœ… Wait for one animation frame (typically 16ms at 60fps)
await page.evaluate(() => new Promise(requestAnimationFrame));

// âœ… Wait for two animation frames (for double-buffered rendering)
await page.evaluate(() => new Promise(resolve => {
  requestAnimationFrame(() => requestAnimationFrame(resolve));
}));
```

**Use Cases for Animation Frame Waiting:**
- Canvas rendering has completed
- CSS transitions have started
- DOM has been painted after state change
- Layout reflow has occurred

### Best Practices

1. **Always wait for specific conditions**:
   ```typescript
   // Bad: Hope it loads in 2 seconds
   await page.waitForTimeout(2000);
   
   // Good: Wait for it to actually load
   await expect(page.locator('.map-canvas')).toBeVisible();
   ```

2. **Use appropriate timeouts for slow operations**:
   ```typescript
   // Key generation can be slow
   await expect(page.locator('.message.success')).toContainText('Registration successful', {
     timeout: 30000 // 30 seconds
   });
   ```

3. **Wait for stability before screenshots**:
   ```typescript
   await page.waitForLoadState('networkidle');
   await expect(page.locator('.content')).toBeVisible();
   await screenshotIfChanged(page, { path: '...' });
   ```

## PR Requirements for UI Changes

**ANY CHANGE THAT MODIFIES THE UI MUST:**

1. âœ… **Include e2e tests** that demonstrate the UI change
2. âœ… **Regenerate screenshots** for affected tests
3. âœ… **Update test README.md** files if verification steps change
4. âœ… **Document new visual elements** in screenshot descriptions
5. âœ… **Verify pixel-perfect rendering** before committing

### Workflow for UI Changes

```bash
# 1. Make UI changes to your code
vim client/src/lib/MyComponent.svelte

# 2. Run e2e tests - they will fail due to screenshot mismatch
npm run test:e2e

# 3. Review the screenshots visually
# - Are the changes correct?
# - Do they match your design intent?
# - Are there any unintended visual regressions?

# 4. If screenshots are correct, update expectations
UPDATE_SCREENSHOTS=1 npm run test:e2e

# 5. Verify tests pass with new screenshots
npm run test:e2e

# 6. Commit changes including new screenshots
git add client/src/lib/MyComponent.svelte
git add e2e/*/screenshots/*.png
git add e2e/*/README.md
git commit -m "Update component styling with new screenshots"
```

### Adding New UI Features

When adding a completely new feature:

```bash
# 1. Create new e2e test folder
mkdir -p e2e/005-new-feature/screenshots

# 2. Write test that:
#    - Exercises the new feature
#    - Verifies state and DOM programmatically
#    - Takes screenshots at each step
#    - Generates README.md

# 3. Run test to generate initial screenshots
npm run test:e2e -- e2e/005-new-feature

# 4. Review screenshots and README
less e2e/005-new-feature/README.md
open e2e/005-new-feature/screenshots/*.png

# 5. Commit everything
git add e2e/005-new-feature/
git commit -m "Add e2e test for new feature"
```

## Test Organization

### Helper Functions

Place reusable test logic in the `e2e/helpers/` directory:

```typescript
// e2e/helpers/auth.ts
export async function registerAndLogin(page: Page, alias: string, password: string) {
  await page.goto('/');
  await page.fill('input#alias', alias);
  await page.fill('input#password', password);
  await page.fill('input#passwordConfirm', password);
  await page.click('button[type="submit"]');
  await expect(page.locator('.authenticated')).toBeVisible();
}

// e2e/helpers/game.ts
export async function createGame(page: Page, maxPlayers: number) {
  await page.click('button:has-text("Create New Game")');
  await page.selectOption('select#maxPlayers', maxPlayers.toString());
  await page.click('button:has-text("Create Game")');
  await expect(page.locator('.game-card')).toBeVisible();
}
```

### Documentation Helper

To tightly couple programmatic verification with documentation, use the `expectation()` helper:

```typescript
// e2e/helpers/expectation.ts
import { expect } from '@playwright/test';

/**
 * Performs a Playwright expectation and returns documentation string
 * This ensures that checks and documentation are always synchronized
 * 
 * @param assertion - The Playwright expect() promise
 * @param description - Human-readable description of what was verified
 * @returns The description string for inclusion in README
 */
export async function expectation<T>(
  assertion: Promise<T>,
  description: string
): Promise<string> {
  await assertion;
  return description;
}

/**
 * Usage example:
 * const doc = await expectation(
 *   expect(page.locator('h1')).toContainText('SimCiv Authentication'),
 *   '- âœ“ Page title contains "SimCiv Authentication"\n'
 * );
 * readmeContent.push(doc);
 */
```

**Benefits of this approach:**
- **Tight coupling**: Check and documentation are in the same statement
- **Synchronization**: Documentation is only generated if the check passes
- **Clarity**: Easy to see exactly what is being verified
- **Maintainability**: Changes to checks automatically update documentation expectations

### Test Setup

Each test file should follow this structure:

```typescript
import { test, expect } from '@playwright/test';
import { clearDatabase, enableE2ETestMode, resetUuidCounter } from '../global-setup';
import { screenshotIfChanged } from '../helpers/screenshot';
import { mockDateInBrowser } from '../helpers/mock-time';
import { registerAndLogin } from '../helpers/auth';

test.beforeEach(async ({ page }) => {
  await enableE2ETestMode();
  await clearDatabase();
  await resetUuidCounter();
  await mockDateInBrowser(page);
});

test.describe('User Registration', () => {
  test('should allow new user registration', async ({ page }) => {
    // Test implementation
  });
});
```

## Example Test

Here's a complete example following all guidelines:

```typescript
import { test, expect } from '@playwright/test';
import { clearDatabase, enableE2ETestMode, resetUuidCounter } from '../global-setup';
import { screenshotIfChanged } from '../helpers/screenshot';
import { mockDateInBrowser } from '../helpers/mock-time';
import { expectation } from '../helpers/expectation';
import fs from 'fs';

test.beforeEach(async ({ page }) => {
  await enableE2ETestMode();
  await clearDatabase();
  await resetUuidCounter();
  await mockDateInBrowser(page);
});

test.describe('000-user-registration', () => {
  test('should complete user registration flow', async ({ page }) => {
    const screenshotDir = 'e2e/000-user-registration/screenshots';
    const readmeContent: string[] = [];
    
    readmeContent.push('# Test: User Registration\n');
    readmeContent.push('## Overview\n');
    readmeContent.push('This test verifies the complete user registration flow.\n\n');
    readmeContent.push('## Screenshots\n\n');

    // Step 1: Initial load
    await page.goto('/');
    await page.waitForURL(/\/id=[a-f0-9-]+/);
    
    // Verify initial state using expectation() helper
    readmeContent.push('### 000-initial-load.png\n');
    readmeContent.push('![000-initial-load.png](screenshots/000-initial-load.png)\n\n');
    readmeContent.push('**Programmatic Verification:**\n');
    readmeContent.push(await expectation(
      expect(page.locator('h1')).toContainText('SimCiv Authentication'),
      '- âœ“ Page title contains "SimCiv Authentication"\n'
    ));
    readmeContent.push(await expectation(
      expect(page.locator('.tabs button.active')).toContainText('Register'),
      '- âœ“ Register tab is active\n'
    ));
    readmeContent.push(await expectation(
      expect(page.locator('input#alias')).toBeVisible(),
      '- âœ“ Registration form is visible\n'
    ));
    readmeContent.push('\n**Manual Visual Verification:**\n');
    readmeContent.push('- Verify page styling and layout\n');
    readmeContent.push('- Check tab styling\n');
    readmeContent.push('- Confirm form field styling\n\n');
    
    await screenshotIfChanged(page, { 
      path: `${screenshotDir}/000-initial-load.png`,
      fullPage: true 
    });

    // Step 2: Fill registration form
    const alias = 'testuser';
    const password = 'TestPassword123!';
    
    await page.fill('input#alias', alias);
    await page.fill('input#password', password);
    await page.fill('input#passwordConfirm', password);
    
    // Verify form is filled using expectation() helper
    readmeContent.push('### 001-form-filled.png\n');
    readmeContent.push('![001-form-filled.png](screenshots/001-form-filled.png)\n\n');
    readmeContent.push('**Programmatic Verification:**\n');
    readmeContent.push(await expectation(
      expect(page.locator('input#alias')).toHaveValue(alias),
      '- âœ“ Alias field contains "testuser"\n'
    ));
    readmeContent.push(await expectation(
      expect(page.locator('button[type="submit"]')).toBeEnabled(),
      '- âœ“ Submit button is enabled\n'
    ));
    readmeContent.push('\n**Manual Visual Verification:**\n');
    readmeContent.push('- Verify input field styling\n');
    readmeContent.push('- Check button hover states\n\n');
    
    await screenshotIfChanged(page, { 
      path: `${screenshotDir}/001-form-filled.png`,
      fullPage: true 
    });

    // Step 3: Submit and verify success
    await page.click('button[type="submit"]');
    
    readmeContent.push('### 002-registration-complete.png\n');
    readmeContent.push('![002-registration-complete.png](screenshots/002-registration-complete.png)\n\n');
    readmeContent.push('**Programmatic Verification:**\n');
    readmeContent.push(await expectation(
      expect(page.locator('.message.success')).toContainText('Registration successful', {
        timeout: 30000
      }),
      '- âœ“ Success message is displayed\n'
    ));
    readmeContent.push(await expectation(
      expect(page.locator('.authenticated')).toBeVisible(),
      '- âœ“ Authenticated section is visible\n'
    ));
    readmeContent.push(await expectation(
      expect(page.locator('.user-info h2')).toContainText(alias),
      '- âœ“ User alias is displayed correctly\n'
    ));
    readmeContent.push('\n**Manual Visual Verification:**\n');
    readmeContent.push('- Verify success message styling\n');
    readmeContent.push('- Check authenticated user layout\n\n');
    
    await screenshotIfChanged(page, { 
      path: `${screenshotDir}/002-registration-complete.png`,
      fullPage: true 
    });

    // Generate README.md
    fs.writeFileSync(
      'e2e/000-user-registration/README.md',
      readmeContent.join('')
    );
  });
});
```

## Common Patterns

### Multi-User Scenarios

```typescript
test('should handle multiple users', async ({ browser }) => {
  // Create separate contexts for different users
  const context1 = await browser.newContext();
  const context2 = await browser.newContext();
  const page1 = await context1.newPage();
  const page2 = await context2.newPage();
  
  await mockDateInBrowser(page1);
  await mockDateInBrowser(page2);
  
  // User 1 actions
  await registerAndLogin(page1, 'user1', 'password');
  
  // User 2 actions
  await registerAndLogin(page2, 'user2', 'password');
  
  // Verify isolation
  await expect(page1.locator('.user-info')).toContainText('user1');
  await expect(page2.locator('.user-info')).toContainText('user2');
  
  await context1.close();
  await context2.close();
});
```

### Form Validation

```typescript
test('should show validation errors', async ({ page }) => {
  await page.goto('/');
  
  // Submit empty form
  await page.click('button[type="submit"]');
  
  // Verify error messages
  await expect(page.locator('.error-message')).toContainText('Alias is required');
  await expect(page.locator('.error-message')).toContainText('Password is required');
  
  // Screenshot showing validation state
  await screenshotIfChanged(page, { 
    path: 'e2e/000-user-registration/screenshots/003-validation-errors.png',
    fullPage: true 
  });
});
```

### State Transitions

```typescript
test('should transition game states correctly', async ({ page }) => {
  await createGame(page, 2);
  
  // Verify initial state
  await expect(page.locator('.game-state')).toContainText('Waiting');
  
  // Join as second player
  // ... join logic ...
  
  // Verify state transition
  await expect(page.locator('.game-state')).toContainText('Starting');
  
  await page.evaluate(() => new Promise(requestAnimationFrame));
  
  await screenshotIfChanged(page, {
    path: 'e2e/002-game-creation/screenshots/005-game-starting.png',
    fullPage: true
  });
});
```

## Debugging Failed Tests

When a test fails:

### 1. Check the Error Message

```
Screenshot mismatch: 001-form-filled.png
The screenshot differs from the expected version.
```

This indicates a visual change occurred.

### 2. Review the Screenshot

```bash
open e2e/000-user-registration/screenshots/001-form-filled.png
```

Ask yourself:
- Is this change intentional?
- Does it match my UI changes?
- Is there an unintended visual regression?

### 3. Check Programmatic Assertions

If the test fails on a DOM assertion:

```
Error: expect(locator).toContainText('Expected Text')
Expected substring: "Expected Text"
Received string: "Actual Text"
```

This indicates a functional bug, not a visual change.

### 4. Review Test Logs

Playwright provides detailed logs:

```bash
npx playwright test --debug
```

Use headed mode to see the browser:

```bash
npx playwright test --headed
```

## Best Practices Summary

1. âœ… **Test user journeys**, not implementation details
2. âœ… **Verify state and DOM programmatically** - don't rely on screenshots for bug detection
3. âœ… **Generate screenshots automatically** at each significant step
4. âœ… **Create README.md files** documenting what was verified
5. âœ… **Use pixel-perfect screenshot comparison** to catch visual regressions
6. âœ… **Never use waitForTimeout** - use event-based waiting
7. âœ… **Wait for animation frames** when needed for rendering
8. âœ… **Update screenshots** when UI intentionally changes
9. âœ… **Use helpers** to avoid code duplication
10. âœ… **Clean up** browser contexts in multi-user tests

## Migration from Current Structure

To migrate existing tests to the new structure:

```bash
# 1. Create new test folder
mkdir -p e2e/000-user-authentication/screenshots

# 2. Move test file
mv e2e/auth.spec.ts e2e/000-user-authentication/test.spec.ts

# 3. Update screenshot paths in test
# Change: 'e2e-screenshots/01-initial-load.png'
# To: 'e2e/000-user-authentication/screenshots/000-initial-load.png'

# 4. Add README generation code to test

# 5. Run test to generate screenshots and README
npm run test:e2e -- e2e/000-user-authentication

# 6. Remove old screenshot files
rm e2e-screenshots/01-*.png
```

Do this gradually, one test at a time, verifying that each migrated test passes before moving to the next.

## Conclusion

These guidelines ensure that:
- E2E tests are **reliable** and **deterministic**
- Tests catch **functional bugs** through programmatic assertions
- Screenshots provide **visual documentation** and catch **styling regressions**  
- Tests represent **real user journeys** that can be understood by humans
- **UI changes are intentional** and require explicit approval

Following these guidelines will result in a robust, maintainable e2e test suite that provides confidence in the application's correctness and visual quality.
