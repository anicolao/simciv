# SimCiv Version 0.0002 Design Specification
## Game Creation, Discovery, and Joining

### Document Status
**Version:** 0.0002  
**Status:** Design Review  
**Last Updated:** 2025-10-22  
**Purpose:** Specification for game list viewing, game creation, and multiplayer game joining

---

## Executive Summary

This document specifies the design for SimCiv's game lobby system, enabling players to create new multiplayer games, browse available games, and join games that are still accepting players. The design focuses on simplicity with a single game creation parameter while providing clear visibility into game state and availability.

**Key Features:**
- Browse list of available games
- Create new game with player count parameter only
- Join games with open slots
- Two game states: "waiting for players" and "started"
- Automatic game start when player quota is met
- Real-time progression: 1 year per real second when started
- Initial game year: 5000 BC

This design builds upon the authentication system from version 0.0001, leveraging existing session management and database architecture to support multiplayer game orchestration.

---

## Architecture Context

This game creation system integrates with the existing SimCiv architecture:
- **Database Layer**: Stores game instances, player memberships, and game state
- **Simulation Engine**: Processes game ticks at 1 year per second for started games
- **Client Layer**: Displays game list, creation UI, and join interface
- **Authentication**: Links games to authenticated users from version 0.0001

The design maintains the database-as-single-source-of-truth principle, with the simulation engine reading game state and player actions from the database.

---

## System Overview

### Game Lifecycle

1. **Game Creation**: Authenticated user creates a game, specifying player count (2-8 players)
2. **Waiting State**: Game enters "waiting for players" state, visible in game list
3. **Player Joining**: Other authenticated users join the game until slots are filled
4. **Auto-Start**: When player count reaches specified limit, game automatically transitions to "started"
5. **Active Play**: Game simulation runs at 1 year per real second, starting at 5000 BC
6. **Ongoing**: Game continues until victory condition met or manually ended

### Game States

**Waiting for Players**
- Game is visible in the lobby
- Shows current player count vs. maximum (e.g., "2/4 players")
- Joinable by any authenticated user not already in the game
- No simulation running
- Can be joined at any time until full

**Started**
- Game is no longer joinable (slots filled)
- Simulation engine actively processing game ticks
- Time progresses at 1 year per real second
- Current year displayed to all players
- Begins at 5000 BC

---

## Game List (Lobby)

### Purpose

Provides players with visibility into all available games, both those waiting for players and those already in progress. Acts as the central hub for game discovery and joining.

### Display Requirements

**Game List View:**
- Shows all games in the system
- Displays for each game:
  - Game name/identifier
  - Creator username
  - Game state ("Waiting for Players" or "Started")
  - Player count (e.g., "3/6 players")
  - For started games: current year (e.g., "Year: 4875 BC")
  - Join button (enabled only for waiting games with open slots)
  - "Spectate" or "View" option for started games (optional)

**Filtering and Sorting:**
- Default sort: Waiting games first, then most recently created
- Optional filters:
  - Show only joinable games
  - Show only games I'm in
  - Show by player count size
  - Show by state (waiting vs. started)

**Real-time Updates:**
- Game list refreshes to show state changes (player joins, game starts)
- Polling or WebSocket subscription to game state changes
- Updates without requiring page reload

### User Interaction

**Viewing:**
- List is accessible from main game menu
- Automatically refreshes every few seconds or via real-time updates
- Shows status of games user is already participating in

**Joining:**
- "Join" button available for waiting games with open slots
- Disabled for games that are full or already started
- Disabled if user is already in the game
- Single click to join (with confirmation optional)

**Spectating (Optional):**
- May view started games as observer
- No interaction with game state
- Read-only view of civilization progress

---

## Game Creation

### Purpose

Allows authenticated users to start a new multiplayer game by specifying how many total players can participate.

### Creation Parameters

**Required:**
- **Player Count**: Number of total players who can join (including creator)
  - Minimum: 2 players
  - Maximum: 8 players (or configurable limit)
  - Default suggested: 4 players

**Automatic/System-Assigned:**
- **Game ID**: Unique identifier generated by system
- **Creator**: Automatically set to authenticated user's alias
- **Creation Time**: Timestamp of game creation
- **Initial State**: "Waiting for Players"
- **Current Players**: 1 (creator automatically joins as first player)
- **Game Year**: Set to 5000 BC (not yet active)
- **Civilization Assignments**: Each player gets a civilization (details per game rules)

### Creation Flow

**User Perspective:**
1. Navigate to "Create Game" from lobby or main menu
2. See simple form with single input: player count
3. Select number of players (dropdown or numeric input)
4. Click "Create Game" button
5. Immediately join game as first player
6. Redirected to game waiting room or back to lobby showing new game

**System Actions:**
1. Validate user is authenticated
2. Validate player count is within allowed range
3. Generate unique game ID
4. Create game record in database with "waiting" state
5. Add creator as first player/civilization
6. Return success and game information
7. Add game to lobby list

**Error Handling:**
- User not authenticated: redirect to login
- Invalid player count: show validation error
- Database error: show generic error, log for investigation
- Ensure user can only create reasonable number of concurrent games (optional limit)

### Game Initialization

**Database Record:**
- Game ID (unique)
- Creator user ID
- Max player count
- Current player count (starts at 1)
- Player list (array of user IDs)
- Game state ("waiting" or "started")
- Current year (5000 BC initially, not advancing until started)
- Created timestamp
- Started timestamp (null until game starts)

**Player/Civilization Setup:**
- Each player assigned a civilization slot
- Civilizations created in database but simulation not active
- Starting conditions defined but not yet processed
- No policies or actions taken until game starts

---

## Joining Existing Games

### Purpose

Enables players to join games that are waiting for additional players, filling open slots until the game reaches capacity and auto-starts.

### Join Eligibility

**Can Join:**
- User is authenticated
- Game is in "waiting" state
- Game has open slots (current players < max players)
- User is not already in this game

**Cannot Join:**
- Game is already "started"
- Game is full (current players = max players)
- User already in the game
- User not authenticated

### Join Flow

**User Perspective:**
1. Browse game list in lobby
2. Identify game with open slots (e.g., "3/4 players")
3. Click "Join" button
4. Immediately become a player in that game
5. See updated player count (e.g., now "4/4 players")
6. If joining filled last slot: game auto-starts

**System Actions:**
1. Validate join eligibility (authenticated, not in game, slots available)
2. Add user to game's player list
3. Increment current player count
4. Create civilization for joining player
5. If current players now equals max players:
   - Transition game state to "started"
   - Set started timestamp
   - Initialize simulation for this game
   - Begin time progression at 5000 BC
6. Update game record in database
7. Broadcast state change to all players in game and lobby viewers

**Error Handling:**
- Game full: show "Game is now full" message
- Already in game: show "You are already in this game"
- Game started between viewing and clicking: show "Game has started"
- Database error: show error message, log issue

### Concurrent Join Handling

**Race Condition Prevention:**
- Use database transaction or atomic update for player addition
- Check slot availability within transaction
- If multiple users try to join last slot simultaneously:
  - First transaction succeeds
  - Subsequent transactions fail with "game full" error
- Ensure player count cannot exceed maximum

---

## Game State Transitions

### Waiting â†’ Started Transition

**Trigger:**
- Occurs automatically when last player joins (current players = max players)
- No manual "start game" action needed
- Instantaneous transition

**Actions on Transition:**
1. Update game state field from "waiting" to "started"
2. Record started timestamp
3. Set game year to 5000 BC
4. Notify simulation engine to begin processing this game
5. Begin tick progression at 1 year per real second
6. Remove game from "joinable" list in lobby
7. Notify all players that game has started
8. Redirect or navigate players to active game view

**Database Updates:**
- `state`: "started"
- `startedAt`: current timestamp
- `currentYear`: -5000 (representing 5000 BC)
- `lastTickAt`: current timestamp

**Simulation Activation:**
- Simulation engine begins processing game ticks
- Each tick represents 1 game year
- Ticks occur every 1 real second
- Game year increments by 1 each tick
- Player policies and actions processed each tick

### No Reverse Transition

**Once Started, Cannot Return to Waiting:**
- Game cannot go back to "waiting" state
- Players cannot leave or be removed once started
- No re-opening of player slots
- Game continues until completion or manual termination

---

## Time Progression

### Real-Time Mapping

**Basic Rule:**
- 1 real-world second = 1 game year
- Begins at 5000 BC when game starts
- Continuously increments while game is active

**Examples:**
- At start (t=0): Year 5000 BC
- After 10 seconds (t=10): Year 4990 BC
- After 5000 seconds (~83 minutes): Year 0 (1 BC to 1 AD transition)
- After 7025 seconds (~117 minutes): Year 2025 AD

### Tick Processing

**Simulation Engine Responsibilities:**
- Poll database for all games in "started" state
- For each started game:
  - Check time since last tick
  - If â‰¥ 1 second has elapsed:
    - Process one game tick
    - Increment game year by 1
    - Update `currentYear` and `lastTickAt` in database
    - Execute simulation logic (citizen AI, resource updates, etc.)
    - Process player actions and policies
    - Generate events and state changes

**Tick Consistency:**
- Each game maintains its own tick timer
- Games are independent (different start times)
- Tick processing may batch multiple games for efficiency
- If server lags, may process multiple ticks to catch up
- Or may skip ticks and interpolate (design decision)

### Time Display

**For Players:**
- Current year prominently displayed (e.g., "4875 BC" or "1825 AD")
- May show BC/AD or BCE/CE based on preference
- Continuous update every second (or at tick intervals)
- Shows time progression visually (animated counter)

**Year Format Examples:**
- Negative numbers: 5000 BC (year -5000)
- Transition: 1 BC â†’ 1 AD (no year 0 in traditional calendar)
- Positive numbers: 2025 AD (year 2025)

**Historical Era Context (Optional):**
- Display era name based on year (Ancient, Classical, Medieval, etc.)
- Provides context for technology and gameplay stage
- Updates as years progress

---

## User Experience Flow

### Complete Player Journey

**New Player Creating Game:**
1. Login with credentials (version 0.0001 auth system)
2. Navigate to lobby/game list
3. Click "Create New Game"
4. Select player count (e.g., 4 players)
5. Click "Create"
6. See confirmation "Game created! Waiting for 3 more players..."
7. View lobby showing own game as "1/4 players"
8. Wait for others to join (may navigate away and return)
9. Receive notification when game fills and starts
10. Redirected to active game view showing "Year: 5000 BC"

**Player Joining Existing Game:**
1. Login with credentials
2. Navigate to lobby/game list
3. Browse available games
4. Select game showing "2/4 players"
5. Click "Join"
6. See confirmation "Joined game! Waiting for 2 more players..."
7. Player count updates to "3/4 players"
8. May wait or navigate away
9. Receive notification when fourth player joins and game starts
10. Redirected to active game view showing "Year: 5000 BC"

**Player Joining as Last Player:**
1. Login with credentials
2. Navigate to lobby/game list
3. Select game showing "3/4 players"
4. Click "Join"
5. Game immediately transitions to "started"
6. Redirected to active game view
7. See "Game started! Year: 5000 BC"
8. All four players now in active game

### Notification System

**When to Notify:**
- Player joins your game
- Game you're in reaches full capacity and starts
- Game state changes

**Notification Methods:**
- In-app notification (if user is logged in)
- UI updates in lobby (real-time)
- Optional: push notification (future enhancement)
- Optional: email notification (future enhancement)

**Notification Content:**
- "Player [username] joined your game"
- "Your game has started! Year: 5000 BC"
- "Game [game-name] is now full (4/4 players)"

---

## Database Schema Extensions

### New Collections/Tables Required

**games:**
- gameId (string, unique, primary key)
- creatorUserId (string, reference to users.alias)
- maxPlayers (integer, 2-8)
- currentPlayers (integer)
- playerList (array of user IDs/aliases)
- state (enum: "waiting", "started")
- currentYear (integer, starts at -5000 for 5000 BC)
- createdAt (timestamp)
- startedAt (timestamp, nullable)
- lastTickAt (timestamp, nullable)

**game_players (or embedded in games):**
- gameId (reference to games)
- userId (reference to users)
- civilizationId (reference to civilizations)
- joinedAt (timestamp)
- joinOrder (integer, 1-based)

**Indexes Required:**
- games.gameId (primary)
- games.state (for filtering waiting vs. started games)
- games.createdAt (for sorting)
- game_players.gameId (for lookups)
- game_players.userId (for finding user's games)

### Queries Needed

**Frequent Queries:**
- List all games (with filters for state)
- Get specific game by ID
- Find games user is in
- Count players in specific game
- Find all started games (for simulation engine)
- Update player count for game
- Update game state
- Increment game year

**Query Optimization:**
- Index on `state` for filtering
- Index on `createdAt` for sorting
- Denormalize current player count to avoid counting array
- Cache frequently accessed game lists

---

## Integration Points

### API Endpoints

**Game Management:**
- GET /api/games: List all games (with optional filters)
- POST /api/games: Create new game
- GET /api/games/:gameId: Get specific game details
- POST /api/games/:gameId/join: Join a game
- GET /api/games/my-games: List games current user is in

**Real-time Updates:**
- WebSocket /ws/lobby: Subscribe to lobby updates
- WebSocket /ws/games/:gameId: Subscribe to specific game updates

**Simulation:**
- Internal: Simulation engine polls for started games
- Internal: Simulation engine updates game years and state

### Client-Side Components

**Lobby Components:**
- Game list view component
- Game list item component (showing state, players, etc.)
- Create game modal/form component
- Join game confirmation component

**Game State Components:**
- Waiting room component (shows players who have joined)
- Game year display component
- Time progression visualization

**Navigation:**
- Lobby view accessible from main menu
- Active game view accessible when in a started game
- Seamless transition between waiting and started states

### Simulation Engine Integration

**Game Discovery:**
- Simulation engine queries database for games with state="started"
- Maintains list of active games to process
- Adds newly started games to processing queue
- Removes completed games from queue

**Tick Processing:**
- For each active game:
  - Calculate time since last tick
  - Process appropriate number of ticks
  - Update currentYear in database
  - Execute simulation logic
  - Update lastTickAt timestamp

**Tick Rate Management:**
- Target: 1 tick per second per game
- Handle multiple games concurrently
- Prioritize tick accuracy over perfect timing
- May batch updates for efficiency

---

## Implementation Considerations

### Scalability

**Database Load:**
- Game list queries may be frequent
- Consider caching lobby data with short TTL
- Use indexes for efficient filtering and sorting
- Monitor query performance

**Simulation Load:**
- Each started game requires continuous tick processing
- Multiple games run concurrently
- Consider horizontal scaling of simulation instances
- May partition games across simulation servers

**Real-time Updates:**
- WebSocket connections for live lobby updates
- May use polling as simpler alternative initially
- Broadcast state changes to connected clients
- Consider server-sent events (SSE) as alternative

### Performance Targets

**Lobby:**
- Game list loads in < 500ms
- Join action completes in < 200ms
- Real-time updates appear within 2 seconds

**Game Creation:**
- Game creation completes in < 500ms
- Immediate feedback to user

**Simulation:**
- Tick processing completes in < 100ms per game
- Accurate 1-second tick interval (Â±50ms)
- Handles at least 100 concurrent games per simulation instance

### Error Recovery

**Database Failures:**
- Retry transient errors
- Log permanent errors
- Show user-friendly error messages
- Maintain consistency (don't partially add player)

**Simulation Failures:**
- Game continues to exist in database
- Simulation attempts to recover on restart
- Calculate missed ticks and catch up (or skip)
- Log failures for investigation

**Network Issues:**
- Client retries join/create requests
- Idempotent operations where possible
- Show connection status to user
- Queue actions when offline (future enhancement)

---

## Security and Validation

### Input Validation

**Player Count:**
- Must be integer between 2 and 8
- Reject values outside this range
- Server-side validation (don't trust client)

**User Authentication:**
- All game operations require authenticated session
- Verify session validity before allowing join/create
- Check user is who they claim to be

**Join Validation:**
- Verify game exists
- Verify game is in "waiting" state
- Verify game has open slots
- Verify user not already in game
- Use transaction to prevent race conditions

### Abuse Prevention

**Rate Limiting:**
- Limit game creation to prevent spam (e.g., 5 games per hour per user)
- Limit join attempts to prevent DoS
- Monitor for suspicious patterns

**Duplicate Prevention:**
- User can only join each game once
- Transaction ensures player count doesn't exceed max
- Unique constraint on (gameId, userId) if using separate table

**Validation at Multiple Layers:**
- Client-side validation for immediate feedback
- Server-side validation as authoritative
- Database constraints as last line of defense

---

## User Interface Mockup (Conceptual)

### Lobby View

```
+------------------------------------------+
|  SimCiv - Game Lobby                    |
|  ----------------------------------------|
|  [Create New Game]                       |
|                                          |
|  Available Games:                        |
|                                          |
|  [JOIN] Game #1234   2/4 players        |
|         Created by: Alice  (Waiting)     |
|                                          |
|  [JOIN] Game #5678   3/6 players        |
|         Created by: Bob    (Waiting)     |
|                                          |
|  [FULL] Game #9012   4/4 players        |
|         Created by: Carol  (Started)     |
|         Year: 4923 BC                    |
|                                          |
|  [FULL] Game #3456   2/2 players        |
|         Created by: Dave   (Started)     |
|         Year: 1850 AD                    |
|                                          |
+------------------------------------------+
```

### Create Game Modal

```
+------------------------------------------+
|  Create New Game                         |
|  ----------------------------------------|
|                                          |
|  Number of Players:                      |
|  [dropdown: 2, 3, 4, 5, 6, 7, 8]        |
|  Selected: 4                             |
|                                          |
|  [Cancel]              [Create Game]     |
|                                          |
+------------------------------------------+
```

### Game Waiting Room

```
+------------------------------------------+
|  Game #1234 - Waiting for Players       |
|  ----------------------------------------|
|                                          |
|  Players: 3/4                            |
|                                          |
|  1. Alice (You) - Ready                  |
|  2. Bob         - Ready                  |
|  3. Carol       - Ready                  |
|  4. [Waiting for player...]              |
|                                          |
|  Game will start automatically when      |
|  all players have joined.                |
|                                          |
|  [Leave Game]                            |
|                                          |
+------------------------------------------+
```

### Active Game Header

```
+------------------------------------------+
|  Game #1234 - Year: 4875 BC             |
|  Players: Alice, Bob, Carol, Dave        |
|  ----------------------------------------|
|  [Your civilization details below...]    |
|                                          |
+------------------------------------------+
```

---

## Testing Requirements

### Unit Tests

**Game Creation:**
- Test valid player counts (2-8)
- Test invalid player counts (< 2, > 8, non-integer)
- Test game initialization with correct defaults
- Test creator automatically becomes first player

**Join Logic:**
- Test successful join with open slots
- Test rejection when game full
- Test rejection when already in game
- Test rejection when game already started
- Test concurrent join attempts (last slot)

**State Transitions:**
- Test transition from "waiting" to "started" when full
- Test that started games cannot be joined
- Test simulation activation on game start

**Time Progression:**
- Test year increment (1 per second)
- Test year display format (BC/AD)
- Test tick timing accuracy
- Test multiple games with different start times

### Integration Tests

**End-to-End Flows:**
- Complete game creation and joining flow
- Multiple players joining sequentially
- Auto-start when last player joins
- Time progression after start
- Lobby updates when game state changes

**Database Integration:**
- Test game creation writes to database
- Test join updates player list and count
- Test state transition persists correctly
- Test concurrent access to same game

**Simulation Integration:**
- Test simulation picks up newly started games
- Test tick processing updates database
- Test multiple games tick independently

### Performance Tests

**Load Testing:**
- Concurrent game creations
- Concurrent joins to same game
- Many games in lobby (100+)
- Many started games being simulated (100+)

**Stress Testing:**
- Race conditions on last join
- Database connection limits
- Simulation tick processing under load

---

## Future Enhancements

### Not in Version 0.0002

The following features are explicitly out of scope for this version but documented for future consideration:

**Advanced Lobby Features:**
- Search and filter games by various criteria
- Private games (invite-only, password-protected)
- Game settings beyond player count (map size, difficulty, etc.)
- Customizable game names
- Pre-game chat room
- Kick/remove players before start

**Time Control:**
- Pause/resume game
- Speed control (2x, 0.5x, etc.)
- Turn-based mode instead of real-time
- Scheduled start time (game starts at specific time)

**Game Management:**
- Leave game before it starts
- Spectator mode for ongoing games
- Save/load game state
- Abandon/surrender from active game
- Vote to end game

**Matchmaking:**
- Skill-based matchmaking
- Automatic game creation and joining
- Quick-play option
- Ranked matches

**Social Features:**
- Friend lists
- Invite specific users to game
- Block/report users
- Player profiles and statistics

**Notifications:**
- Push notifications to mobile
- Email notifications
- Discord/webhook integrations

---

## Design Alternatives Considered

### Alternative 1: Manual Game Start

**Description:** Require game creator to click "Start Game" button instead of auto-starting when full.

**Rejected Because:**
- Adds unnecessary complexity
- Creator might forget to start or be AFK
- Delays game start for all players
- Auto-start provides better UX

### Alternative 2: Complex Game Configuration

**Description:** Allow configuration of map size, difficulty, starting resources, time scale, etc.

**Rejected Because:**
- Violates requirement for single parameter (player count)
- Overwhelming for new players
- Can be added later if needed
- Simplicity is better for MVP

### Alternative 3: Turn-Based Instead of Real-Time

**Description:** Make game turn-based (each player takes a turn) rather than real-time progression.

**Rejected Because:**
- Requirements specifically state "1 year per real second"
- Real-time better matches simulation vision
- Turn-based fundamentally different game feel
- Can be added as separate game mode later

### Alternative 4: Lobby Chat or Pre-Game Communication

**Description:** Add chat room for players waiting in game lobby.

**Rejected Because:**
- Out of scope for minimal viable lobby
- Can be added in future version
- Focus is on core game mechanics
- May add moderation complexity

### Alternative 5: Variable Time Scales

**Description:** Allow different games to run at different speeds (1 year per second, 1 year per minute, etc.).

**Rejected Because:**
- Requirement specifies exactly "1 year per real second"
- Adds complexity to lobby UI and game configuration
- Can be future enhancement if needed
- Simplicity preferred for MVP

---

## Success Criteria

### Functional Requirements

- [ ] Users can view list of all games
- [ ] Users can create new game by specifying player count (2-8)
- [ ] Users can join games that are waiting and have open slots
- [ ] Games automatically start when player limit reached
- [ ] Started games cannot be joined
- [ ] Game year starts at 5000 BC
- [ ] Time progresses at 1 year per real second in started games
- [ ] Lobby shows accurate game state (waiting vs. started)
- [ ] Lobby shows current player counts
- [ ] Players can see which games they are in

### Non-Functional Requirements

- [ ] Game creation completes in < 500ms
- [ ] Join action completes in < 200ms
- [ ] Lobby updates appear within 2 seconds
- [ ] Tick processing maintains 1 second interval (Â±50ms)
- [ ] System handles 100+ concurrent games
- [ ] No race conditions allow player count to exceed maximum
- [ ] All database operations are transactional and consistent

### User Experience

- [ ] Lobby UI is intuitive and self-explanatory
- [ ] Clear feedback when creating or joining game
- [ ] Obvious indication of game state (waiting vs. started)
- [ ] Smooth transition from waiting to started
- [ ] Current year prominently displayed in active games
- [ ] Error messages are clear and helpful

---

## Conclusion

This design provides a simple, streamlined approach to multiplayer game creation and joining in SimCiv. By focusing on a single configuration parameter (player count) and two clear game states (waiting vs. started), the system remains approachable for new players while providing the foundation for engaging multiplayer gameplay.

**Key Strengths:**

1. **Simplicity**: Single parameter for game creation reduces complexity
2. **Clarity**: Two distinct game states are easy to understand
3. **Automation**: Auto-start when full eliminates manual coordination
4. **Real-time**: 1 year per second provides engaging progression
5. **Scalability**: Design supports many concurrent games
6. **Integration**: Builds cleanly on existing authentication system

The automatic game start when player capacity is reached ensures smooth progression from lobby to active gameplay, while the real-time year progression (1 year per second starting at 5000 BC) creates an engaging sense of civilization development over time.

This specification integrates seamlessly with the authentication system from version 0.0001 and the database-centric architecture from the initial design, setting the stage for the core gameplay loop where players guide their civilizations through the ages.

---

*This design document is ready for review and approval. Implementation should not begin until this design has been approved.*
