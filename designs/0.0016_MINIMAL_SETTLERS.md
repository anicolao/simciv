# SimCiv Minimal Settlers Implementation Design Specification
## First Cut Implementation for Population-Based Expansion

### Document Status
**Version:** 0.0016  
**Status:** Design Review  
**Last Updated:** 2025-10-30  
**Purpose:** Specification for the minimal viable implementation of the settlers system to enable basic civilization expansion

---

## Executive Summary

This document specifies the **minimal first cut implementation** of the settlers system for SimCiv. Rather than implementing the full system described in 0.0015_UNIT_CREATION.md (version 0.0015), this design focuses on the absolute minimum required to validate the core mechanics and enable basic gameplay.

**Key Features of Minimal Implementation:**
- Single settlers unit at game start (100 population)
- Simple autonomous settlement placement (3-step random walk then settle)
- Single settlement type (nomadic camp)
- Basic population growth at settlement
- Simple UI for viewing unit and settlement

**Deliberately Excluded from First Cut:**
- Complex AI pathfinding and tile scoring
- Multiple unit types (warriors, scouts, workers)
- Technology-dependent settlement types
- Cultural borders and territory control
- Second settlers unit creation
- Movement points and terrain costs
- User-controlled settlement placement

**Success Criteria:**
A successful minimal implementation allows:
1. Game starts with 100 population and 1 settlers unit
2. Settlers unit automatically takes 3 random steps
3. Settlers unit automatically settles at its location after 3 steps
4. Settlement appears and settlers unit disappears
5. Population begins to grow at the new settlement

This minimal design serves as a proof-of-concept for the full settlers system while keeping implementation scope extremely small and focused on validation of core mechanics.

---

## Related Documents

- **0.0015_UNIT_CREATION.md**: Full settlers system design (this is a minimal subset)
- **0.0006_MINIMAL_SIMULATOR.md**: Population simulation and growth mechanics
- **0.0003_MAP_GENERATION.md**: Terrain types and map structure
- **0.0002_GAME_CREATION.md**: Game initialization and player setup

---

## Scope: What's In and What's Out

### In Scope (Minimal Implementation)

**Game Initialization:**
- ✓ Start game with 100 population
- ✓ Create 1 settlers unit at starting position
- ✓ Settlers unit has no settlement (pre-settlement state)

**Unit Display:**
- ✓ Show settlers icon on map at unit's location
- ✓ Display unit information when viewing map

**Autonomous Settlement:**
- ✓ Simple 3-step random walk from starting position
- ✓ Basic validation: tile is land, not ocean
- ✓ Automatic settlement after 3 steps
- ✓ Remove settlers unit
- ✓ Allocate 100 population to settlement

**Settlement Display:**
- ✓ Show settlement icon on map
- ✓ Display settlement information (location, population, type)

**Population Growth:**
- ✓ Use existing 0.0006_MINIMAL_SIMULATOR.md mechanics for growth at settlement
- ✓ Population grows from 100 over time

### Out of Scope (Future Implementations)

**Advanced Autonomous Behavior:**
- ✗ Complex AI pathfinding and movement
- ✗ Tile scoring algorithms
- ✗ Intelligent settlement selection
- ✗ Unit states (searching, moving, settling)

**Multiple Units:**
- ✗ Creating second settlers unit
- ✗ Unit threshold checking (pop 200 → new settlers)
- ✗ Multiple units on map simultaneously
- ✗ Other unit types (warriors, scouts, workers)

**Advanced Features:**
- ✗ Movement points and terrain costs
- ✗ Vision range and fog of war
- ✗ Cultural borders
- ✗ Territory control
- ✗ Technology-dependent settlement types (only nomadic camp)
- ✗ Settlement spacing rules (3-tile minimum)
- ✗ Resource-based tile scoring
- ✗ Multiple settlements per player

**UI Polish:**
- ✗ Hover previews for settlement placement
- ✗ Valid/invalid tile highlighting
- ✗ Animation for settlement creation
- ✗ Detailed notifications and alerts
- ✗ Path visualization
- ✗ Tile score display

---

## Architecture Context

The minimal settlers implementation integrates with SimCiv's existing architecture:

- **Database Layer**: Stores single unit and single settlement per player
- **Simulation Engine**: Uses existing population growth from 0.0006_MINIMAL_SIMULATOR.md, handles 3-step movement and auto-settlement
- **Client Layer**: Basic map rendering for unit and settlement
- **Game State**: Tracks unit existence and settlement creation

The design maintains the database-as-single-source-of-truth principle while deferring complex logic to future iterations.

---

## Data Model

### Units Collection

```typescript
interface Unit {
  unitId: string;                    // Unique unit identifier
  gameId: string;                    // Game this unit belongs to
  playerId: string;                  // Player who owns this unit
  unitType: "settlers";              // Only settlers in minimal implementation
  
  location: {
    x: number;                       // Current tile X coordinate
    y: number;                       // Current tile Y coordinate
  };
  
  stepsTaken: number;                // Number of movement steps taken (0-3)
  
  populationCost: 100;               // Fixed at 100 for settlers
  
  createdAt: Date;                   // When unit was created
  lastUpdated: Date;                 // Last state change
}
```

**Simplifications from full design:**
- No `state` field (no complex AI behavior states)
- No `movement` object (no complex pathfinding)
- No `searchState` (no tile evaluation)
- Only `unitType: "settlers"` supported
- Simple `stepsTaken` counter for 3-step walk

### Settlements Collection

```typescript
interface Settlement {
  settlementId: string;              // Unique settlement identifier
  gameId: string;                    // Game this settlement belongs to
  playerId: string;                  // Player who owns this settlement
  name: string;                      // Auto-generated name (e.g., "First Settlement")
  type: "nomadic_camp";              // Only nomadic camp in minimal implementation
  
  location: {
    x: number;                       // Settlement tile X coordinate
    y: number;                       // Settlement tile Y coordinate
  };
  
  population: number;                // Initially 100, grows over time
  
  founded: Date;                     // When settlement was founded
  lastUpdated: Date;                 // Last population/state update
}
```

**Simplifications from full design:**
- No `culturalBorders` (no territory control)
- No `bonuses` (no technology effects)
- No `workingTiles` (no resource system)
- Only `type: "nomadic_camp"` supported

### Game State Extension

Update existing game state to track unit and settlement:

```typescript
interface GamePlayer {
  // ... existing fields (playerId, civilization, startingPosition, etc.)
  
  unitId: string | null;             // ID of player's settlers unit (null after settled)
  settlementId: string | null;       // ID of player's first settlement (null before settled)
  
  // Future: arrays for multiple units/settlements
  // units: string[];
  // settlements: string[];
}
```

---

## Game Initialization

### Starting State

When a game is created with player(s):

**Step 1: Create Initial Units (for each player)**
```typescript
// In game engine initialization, after map generation
for (const player of game.players) {
  // Create initial settlers unit
  const unit = {
    unitId: generateUUID(),
    gameId: game.gameId,
    playerId: player.playerId,
    unitType: "settlers",
    location: player.startingPosition,  // From map generation
    stepsTaken: 0,                      // Haven't moved yet
    populationCost: 100,
    createdAt: new Date(),
    lastUpdated: new Date()
  };
  
  await db.collection('units').insertOne(unit);
  
  // Update game state to track unit
  player.unitId = unit.unitId;
  player.settlementId = null;
}
```

**Step 2: Initialize Population**
```typescript
// Create population tracking document
for (const player of game.players) {
  const population = {
    gameId: game.gameId,
    playerId: player.playerId,
    totalPopulation: 100,              // Starting population
    allocatedToUnit: 100,              // All pop in settlers unit
    allocatedToSettlement: 0,          // No settlement yet
    unallocated: 0,                    // Nothing unallocated
    lastUpdated: new Date()
  };
  
  await db.collection('population').insertOne(population);
}
```

**Initial Game State Summary:**
- Population: 100 (all in settlers unit)
- Units: 1 settlers unit at starting position with stepsTaken: 0
- Settlements: 0 (none yet)
- Behavior: Settlers will automatically begin 3-step random walk on next tick

---

## Autonomous 3-Step Settlement Algorithm

### Simple Random Walk Strategy

The minimal implementation uses a trivially simple autonomous settlement strategy:

**Algorithm:**
1. Each game tick, if unit has `stepsTaken < 3`, move one step in a random direction
2. After 3 steps, settle at current location (with basic validation)
3. If settlement location is invalid (ocean), retry settlement on next valid adjacent tile

**Pseudocode:**
```typescript
async function processSettlersUnit(unit: Unit) {
  // If unit has taken fewer than 3 steps, take another step
  if (unit.stepsTaken < 3) {
    // Pick random direction: N, S, E, W
    const directions = [
      { dx: 0, dy: -1 },  // North
      { dx: 0, dy: 1 },   // South
      { dx: 1, dy: 0 },   // East
      { dx: -1, dy: 0 }   // West
    ];
    
    const direction = directions[Math.floor(Math.random() * directions.length)];
    
    // Move unit
    unit.location.x += direction.dx;
    unit.location.y += direction.dy;
    unit.stepsTaken += 1;
    
    // Ensure within map bounds
    unit.location.x = Math.max(0, Math.min(mapWidth - 1, unit.location.x));
    unit.location.y = Math.max(0, Math.min(mapHeight - 1, unit.location.y));
    
    await db.collection('units').updateOne(
      { unitId: unit.unitId },
      { $set: { location: unit.location, stepsTaken: unit.stepsTaken, lastUpdated: new Date() } }
    );
    
    return; // Wait for next tick
  }
  
  // If unit has taken 3 steps, settle
  if (unit.stepsTaken === 3) {
    await settleAtLocation(unit, unit.location);
  }
}
```

**Settlement Validation:**
```typescript
async function settleAtLocation(unit: Unit, location: {x: number, y: number}) {
  // Get tile at location
  const tile = await db.collection('tiles').findOne({
    gameId: unit.gameId,
    x: location.x,
    y: location.y
  });
  
  // If tile is ocean, find nearest non-ocean tile
  if (!tile || tile.terrain === 'OCEAN' || tile.terrain === 'SHALLOW_WATER') {
    // Try adjacent tiles (spiral search)
    const adjacentTiles = [
      { x: location.x + 1, y: location.y },
      { x: location.x - 1, y: location.y },
      { x: location.x, y: location.y + 1 },
      { x: location.x, y: location.y - 1 }
    ];
    
    for (const adjLocation of adjacentTiles) {
      const adjTile = await db.collection('tiles').findOne({
        gameId: unit.gameId,
        x: adjLocation.x,
        y: adjLocation.y
      });
      
      if (adjTile && adjTile.terrain !== 'OCEAN' && adjTile.terrain !== 'SHALLOW_WATER') {
        location = adjLocation;
        break;
      }
    }
  }
  
  // Create settlement
  const settlement = {
    settlementId: generateUUID(),
    gameId: unit.gameId,
    playerId: unit.playerId,
    name: "First Settlement",
    type: "nomadic_camp",
    location: location,
    population: 100,
    founded: new Date(),
    lastUpdated: new Date()
  };
  
  await db.collection('settlements').insertOne(settlement);
  
  // Remove settlers unit
  await db.collection('units').deleteOne({ unitId: unit.unitId });
  
  // Update game state
  await db.collection('games').updateOne(
    { gameId: unit.gameId, "players.playerId": unit.playerId },
    { 
      $set: { 
        "players.$.unitId": null,
        "players.$.settlementId": settlement.settlementId
      }
    }
  );
  
  // Update population allocation
  await db.collection('population').updateOne(
    { gameId: unit.gameId, playerId: unit.playerId },
    { 
      $set: {
        allocatedToUnit: 0,
        allocatedToSettlement: 100,
        lastUpdated: new Date()
      }
    }
  );
}
```

### Why This Strategy Works

**Advantages:**
- **Extremely simple**: No pathfinding, no tile evaluation, no decision-making
- **Deterministic steps**: Always 3 steps, predictable behavior
- **Automatic**: No user intervention required
- **Fast**: Minimal computation per tick
- **Valid for testing**: Creates settlement quickly so population growth can be tested

**Limitations (acceptable for minimal implementation):**
- Settlement location is random, not optimal
- May settle in poor locations (tundra, desert, etc.)
- No consideration of resources, terrain quality, or strategic value
- Fixed 3 steps regardless of map size

**Future Enhancement Path:**
This simple strategy can be replaced with the full autonomous AI from 0.0015_UNIT_CREATION.md without changing the data model or API, making it a true minimal implementation that doesn't create throwaway code.

---

## Client Implementation

### Map Rendering

**Minimal Map View Updates:**

```typescript
// In existing map rendering code

// Render units layer (after terrain but before UI)
function renderUnits(ctx, gameState, viewport) {
  const currentPlayer = gameState.currentPlayer;
  
  // Find player's unit
  const unit = gameState.units.find(u => u.playerId === currentPlayer.playerId);
  
  if (unit) {
    const screenPos = worldToScreen(unit.location, viewport);
    
    // Draw simple settlers icon (or use emoji: 🚶)
    ctx.font = '32px Arial';
    ctx.fillText('🚶', screenPos.x - 16, screenPos.y + 16);
    
    // Optional: draw circle around unit for visibility
    ctx.strokeStyle = currentPlayer.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y, 20, 0, 2 * Math.PI);
    ctx.stroke();
  }
}

// Render settlements layer
function renderSettlements(ctx, gameState, viewport) {
  for (const settlement of gameState.settlements) {
    const screenPos = worldToScreen(settlement.location, viewport);
    
    // Draw settlement icon (or use emoji: ⭐)
    ctx.font = '40px Arial';
    ctx.fillText('⭐', screenPos.x - 20, screenPos.y + 20);
    
    // Draw settlement name
    ctx.font = '12px Arial';
    ctx.fillStyle = 'white';
    ctx.fillText(settlement.name, screenPos.x - 30, screenPos.y + 35);
  }
}
```

### UI Information Panel

```typescript
// Simple info panel when hovering over unit or settlement
function renderInfoPanel(ctx, entity) {
  if (entity.type === 'unit') {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(10, 10, 220, 100);
    
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`Settlers Unit`, 20, 30);
    ctx.fillText(`Population: 100`, 20, 50);
    ctx.fillText(`Location: (${entity.location.x}, ${entity.location.y})`, 20, 70);
    ctx.fillText(`Steps taken: ${entity.stepsTaken}/3`, 20, 90);
    ctx.font = '12px Arial';
    ctx.fillText(`Searching for settlement site...`, 20, 110);
  } else if (entity.type === 'settlement') {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(10, 10, 200, 100);
    
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`${entity.name}`, 20, 30);
    ctx.fillText(`Type: Nomadic Camp`, 20, 50);
    ctx.fillText(`Population: ${entity.population}`, 20, 70);
    ctx.fillText(`Location: (${entity.location.x}, ${entity.location.y})`, 20, 90);
  }
}
```

---

## Server API Endpoints

### New Endpoints for Minimal Implementation

**1. Get Units (for map rendering)**
```
GET /api/game/{gameId}/units
Returns: Array of units for current player

Response:
{
  "units": [
    {
      "unitId": "uuid",
      "unitType": "settlers",
      "location": { "x": 50, "y": 50 },
      "stepsTaken": 2,
      "populationCost": 100
    }
  ]
}
```

**2. Get Settlements (for map rendering)**
```
GET /api/game/{gameId}/settlements
Returns: Array of settlements for current player

Response:
{
  "settlements": [
    {
      "settlementId": "uuid",
      "name": "First Settlement",
      "type": "nomadic_camp",
      "location": { "x": 52, "y": 53 },
      "population": 125
    }
  ]
}
```

**Note:** No manual settlement endpoint needed - settlement happens automatically after 3 steps.

---

## Population Growth Integration

### Using Existing 0.0006_MINIMAL_SIMULATOR.md

The minimal settlers implementation leverages the existing population simulation from 0.0006_MINIMAL_SIMULATOR.md:

**At Each Game Tick:**
```typescript
// In existing game engine tick processing

async function processGameTick(gameId) {
  // ... existing tick logic ...
  
  // Process settlers units (3-step walk and auto-settle)
  const units = await db.collection('units').find({ gameId, unitType: 'settlers' }).toArray();
  
  for (const unit of units) {
    await processSettlersUnit(unit);
  }
  
  // For each settlement, run population simulation
  const settlements = await db.collection('settlements').find({ gameId }).toArray();
  
  for (const settlement of settlements) {
    // Use existing human simulation logic
    const popGrowth = await simulatePopulationTick(
      settlement.population,
      settlement.gameId,
      settlement.playerId
    );
    
    // Update settlement population
    await db.collection('settlements').updateOne(
      { settlementId: settlement.settlementId },
      { 
        $set: { 
          population: settlement.population + popGrowth,
          lastUpdated: new Date()
        }
      }
    );
    
    // Update population tracking
    await db.collection('population').updateOne(
      { gameId: gameId, playerId: settlement.playerId },
      {
        $inc: { 
          totalPopulation: popGrowth,
          allocatedToSettlement: popGrowth
        },
        $set: { lastUpdated: new Date() }
      }
    );
  }
}
```

**Key Points:**
- No changes needed to existing 0.0006_MINIMAL_SIMULATOR.md logic
- Population grows at settlements using existing formulas
- No population growth in settlers units (all growth happens after settling)
- Future implementation will add second settlers threshold check at pop 200

---

## Testing Strategy

### Unit Tests

**Unit Creation:**
- Test game initialization creates settlers unit with correct data
- Test unit has correct starting position
- Test population allocation is correct (100 in unit, 0 in settlement)
- Test stepsTaken initialized to 0

**3-Step Movement:**
- Test unit moves 1 step per tick
- Test unit stays within map bounds
- Test stepsTaken increments correctly
- Test unit stops moving after 3 steps

**Settlement Validation:**
- Test settlement fails gracefully on OCEAN tiles (finds adjacent land)
- Test settlement succeeds on GRASSLAND, PLAINS, FOREST, etc.
- Test settlement is created with correct initial values

**Settlement Creation:**
- Test settlement is created after 3 steps
- Test settlement has correct location
- Test settlement has correct initial values (type, population, name)
- Test settlers unit is removed after settlement
- Test population is transferred from unit to settlement
- Test game state is updated correctly

**Database Consistency:**
- Test population tracking remains consistent (totalPop = unit + settlement)
- Test unit is properly deleted from database
- Test settlement is properly inserted into database

### Integration Tests

**Complete Settlement Flow:**
1. Start new game
2. Verify initial settlers unit exists at starting position
3. Verify stepsTaken = 0
4. Simulate 3 game ticks
5. Verify unit has moved 3 times and stepsTaken = 3
6. Simulate 1 more tick
7. Verify settlement is created
8. Verify unit is removed
9. Verify population allocated correctly

**Population Growth at Settlement:**
1. Create settlement (through 4-tick flow above)
2. Run several more game ticks
3. Verify settlement population increases
4. Verify population tracking updated correctly

### Manual Testing Checklist

**Initial State:**
- [ ] Start new game
- [ ] Verify map loads and displays
- [ ] Verify settlers unit appears at starting position
- [ ] Verify unit icon is visible and correctly positioned

**Autonomous Movement:**
- [ ] Wait 3 seconds (3 game ticks)
- [ ] Verify settlers unit has moved
- [ ] Verify unit is not at starting position
- [ ] Verify stepsTaken visible in UI (if displayed)

**Autonomous Settlement:**
- [ ] Wait 1 more second (1 game tick after 3 steps)
- [ ] Verify settlement appears at unit's final location
- [ ] Verify settlers unit disappears
- [ ] Verify settlement icon is visible

**Population Growth:**
- [ ] Wait for several game ticks (5-10 seconds)
- [ ] Hover over settlement
- [ ] Verify population has increased from initial 100
- [ ] Verify population continues growing over time

### E2E Tests (Playwright)

**E2E Test Suite: minimal-settlers.spec.ts**

```typescript
test('Initial settlers unit appears at game start', async ({ page }) => {
  // Create and join game
  await createAndJoinGame(page);
  
  // Wait for map to load
  await page.waitForSelector('canvas');
  
  // Verify settlers unit is visible on map
  const gameState = await page.evaluate(() => {
    return window.gameState; // Assuming game state exposed for testing
  });
  
  expect(gameState.units).toHaveLength(1);
  expect(gameState.units[0].unitType).toBe('settlers');
  expect(gameState.units[0].stepsTaken).toBe(0);
  
  await page.screenshot({ path: 'e2e-screenshots/36-initial-settlers-unit.png' });
});

test('Settlers unit moves autonomously for 3 steps', async ({ page }) => {
  // Create and join game
  await createAndJoinGame(page);
  await page.waitForSelector('canvas');
  
  // Get initial position
  let gameState = await page.evaluate(() => window.gameState);
  const initialX = gameState.units[0].location.x;
  const initialY = gameState.units[0].location.y;
  
  // Wait for 3 ticks (3 seconds)
  await page.waitForTimeout(3000);
  
  // Verify unit has moved
  gameState = await page.evaluate(() => window.gameState);
  const finalX = gameState.units[0].location.x;
  const finalY = gameState.units[0].location.y;
  
  expect(gameState.units[0].stepsTaken).toBe(3);
  expect(finalX !== initialX || finalY !== initialY).toBe(true);
  
  await page.screenshot({ path: 'e2e-screenshots/37-settlers-moved-3-steps.png' });
});

test('Settlement created automatically after 3 steps', async ({ page }) => {
  // Create and join game
  await createAndJoinGame(page);
  await page.waitForSelector('canvas');
  
  // Wait for 3 steps + 1 settlement tick (4 seconds)
  await page.waitForTimeout(4000);
  
  // Verify settlement exists and unit is gone
  const gameState = await page.evaluate(() => window.gameState);
  
  expect(gameState.units).toHaveLength(0);
  expect(gameState.settlements).toHaveLength(1);
  expect(gameState.settlements[0].type).toBe('nomadic_camp');
  expect(gameState.settlements[0].population).toBe(100);
  
  await page.screenshot({ path: 'e2e-screenshots/38-settlement-created.png' });
});

test('Settlement population grows over time', async ({ page }) => {
  // Create game and wait for settlement
  await createAndJoinGame(page);
  await page.waitForSelector('canvas');
  await page.waitForTimeout(4000); // Wait for settlement
  
  // Get initial population
  let gameState = await page.evaluate(() => window.gameState);
  const initialPop = gameState.settlements[0].population;
  
  // Wait for population growth (10 seconds = 10 ticks)
  await page.waitForTimeout(10000);
  
  // Get updated population
  gameState = await page.evaluate(() => window.gameState);
  const finalPop = gameState.settlements[0].population;
  
  expect(finalPop).toBeGreaterThan(initialPop);
  
  await page.screenshot({ path: 'e2e-screenshots/39-population-growth.png' });
});
```

---

## Implementation Checklist

### Phase 1: Database Schema (1-2 hours)

- [ ] Create `units` collection schema with `stepsTaken` field
- [ ] Create `settlements` collection schema
- [ ] Add `unitId` and `settlementId` to game player tracking
- [ ] Add `population` collection for tracking allocations
- [ ] Create database indexes for efficient queries

### Phase 2: Game Initialization (2-3 hours)

- [ ] Modify game creation to initialize settlers unit for each player
- [ ] Set `stepsTaken` to 0 for new units
- [ ] Set up population tracking (100 pop in unit, 0 in settlement)
- [ ] Verify unit created at player starting position
- [ ] Write unit tests for initialization logic

### Phase 3: Autonomous Movement & Settlement (3-4 hours)

- [ ] Implement `processSettlersUnit()` function with 3-step random walk
- [ ] Implement boundary checking (keep unit within map)
- [ ] Implement `settleAtLocation()` with ocean tile validation
- [ ] Update unit on each tick until stepsTaken = 3
- [ ] Trigger settlement creation when stepsTaken = 3
- [ ] Write unit tests for movement logic
- [ ] Write unit tests for settlement logic
- [ ] Write integration tests for complete 4-tick flow

### Phase 4: Server API (2-3 hours)

- [ ] Implement `GET /api/game/{gameId}/units` endpoint
- [ ] Implement `GET /api/game/{gameId}/settlements` endpoint
- [ ] Write unit tests for endpoints
- [ ] Write integration tests for data retrieval

### Phase 5: Client Integration (3-4 hours)

- [ ] Add units to game state loading
- [ ] Render settlers icon on map at unit location
- [ ] Render settlement icon on map
- [ ] Add hover info panel for unit and settlement
- [ ] Display stepsTaken in unit info
- [ ] Test in browser with manual testing

### Phase 6: Population Growth Integration (1-2 hours)

- [ ] Modify game tick to call `processSettlersUnit()` for active units
- [ ] Modify game tick to process settlement population
- [ ] Use existing 0.0006_MINIMAL_SIMULATOR.md for growth calculations
- [ ] Update population tracking after each tick
- [ ] Verify population grows correctly over time

### Phase 7: Testing and Polish (3-4 hours)

- [ ] Run all unit tests
- [ ] Run all integration tests
- [ ] Run manual testing checklist
- [ ] Write and run E2E tests
- [ ] Fix any bugs found
- [ ] Take screenshots for documentation

**Total Estimated Time: 15-22 hours**

---

## Success Criteria

### Functional Requirements

**✓ Game Initialization:**
- New game creates 1 settlers unit per player
- Unit appears at correct starting position with stepsTaken = 0
- Population tracking initialized correctly

**✓ Autonomous Movement:**
- Unit moves 1 step per tick for first 3 ticks
- Unit stays within map bounds
- stepsTaken increments correctly
- Movement is random (different directions each game)

**✓ Autonomous Settlement:**
- Settlement created automatically after 3 steps
- Settlement succeeds on land tiles
- Settlement handles ocean tiles gracefully (finds adjacent land)
- Settlement has correct data

**✓ State Updates:**
- Settlers unit is removed after settlement
- Settlement appears on map
- Population allocated correctly (from unit to settlement)
- Game state reflects changes

**✓ Population Growth:**
- Settlement population grows over time using existing mechanics
- Population tracking updated correctly
- Growth rate matches 0.0006_MINIMAL_SIMULATOR.md expectations

### Technical Requirements

**✓ Database Consistency:**
- No duplicate units or settlements
- Population tracking always consistent
- All foreign keys valid (gameId, playerId, etc.)

**✓ API Correctness:**
- All endpoints return proper status codes
- Data returned matches database state

**✓ UI Functionality:**
- Map renders units and settlements correctly
- Info panel displays current state accurately
- Autonomous behavior visible to player

**✓ Test Coverage:**
- All unit tests pass
- All integration tests pass
- All E2E tests pass
- Manual testing checklist complete

---

## Future Enhancements (Not in Minimal Implementation)

After the minimal implementation is validated, future iterations can add:

**Phase 2: Intelligent Autonomous Settlement (from version 0.0015)**
- AI pathfinding and movement
- Tile scoring algorithm
- Intelligent settlement selection
- Unit states (searching, moving, settling)

**Phase 3: Multiple Units**
- Second settlers creation at pop 200
- Multiple units on map simultaneously
- Unit threshold checking and notifications

**Phase 4: Advanced Features**
- Technology-dependent settlement types
- Cultural borders and territory
- Settlement spacing rules
- Multiple settlements per player
- Movement points and terrain costs

**Phase 5: Other Unit Types**
- Warriors for defense
- Scouts for exploration
- Workers for improvements

---

## Dependencies and Prerequisites

**Existing Systems Required:**
- Game creation and initialization (version 0.0002)
- Map generation with terrain types (version 0.0003)
- Population simulation mechanics (version 0.0006)
- Client map rendering with canvas

**Database:**
- MongoDB collections for units and settlements
- Existing collections: games, tiles, players, population

**Client:**
- Canvas-based map rendering
- Game state loading and display

**Server:**
- Express API endpoints
- Database connection and queries
- Game tick processing loop (1 tick per second)

---

## Open Questions for Implementation

1. **Step Direction Randomization:** Use Math.random() or seeded RNG for reproducibility?
2. **Unit Icon:** Use emoji (🚶) or create custom SVG sprite?
3. **Settlement Icon:** Use emoji (⭐) or create custom icon?
4. **Auto-naming:** Use "First Settlement" or generate names like "Settlement 1"?
5. **Map Zoom:** Handle unit/settlement rendering at different zoom levels?
6. **Tick Rate:** Is 1 second per tick appropriate for watching 3-step movement?
7. **Adjacent Tile Search:** Should we guarantee settlement placement or allow failure?

---

## Conclusion

This minimal settlers implementation provides the **absolute minimum** functionality needed to validate the core mechanics of the population-based expansion system. By using a trivially simple 3-step random walk strategy instead of manual clicking or complex AI, the implementation:

- **Requires no throwaway code** - The simple autonomous strategy can be directly replaced with the full AI from 0.0015_UNIT_CREATION.md
- **Tests the complete flow** - Unit creation → movement → settlement → population growth
- **Enables rapid validation** - Settlement happens in 4 seconds, allowing quick testing
- **Maintains future compatibility** - Data model and API support full implementation

The success of this minimal implementation will validate:
- Population threshold mechanics (100 pop → 1 settlers)
- Autonomous settlement workflow
- Population growth at settlements
- Database structure and API design
- Client rendering and display

Once validated, this foundation enables confident implementation of the full autonomous settlers system described in version 0.0015, with the knowledge that the core mechanics are sound and the architecture supports the required functionality.

This minimal-first approach follows software engineering best practices: **build the simplest thing that could possibly work, validate it, then iterate toward the full design**.
