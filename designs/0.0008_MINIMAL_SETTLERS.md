# SimCiv Minimal Settlers Implementation Design Specification
## First Cut Implementation for Population-Based Expansion

### Document Status
**Version:** 0.0008  
**Status:** Design Review  
**Last Updated:** 2025-10-30  
**Purpose:** Specification for the minimal viable implementation of the settlers system to enable basic civilization expansion

---

## Executive Summary

This document specifies the **minimal first cut implementation** of the settlers system for SimCiv. Rather than implementing the full system described in 0.0007_UNIT_CREATION.md (version 0.0007), this design focuses on the absolute minimum required to validate the core mechanics and enable basic gameplay.

**Key Features of Minimal Implementation:**
- Single settlers unit at game start (100 population)
- Manual settlement placement (no autonomous AI)
- Single settlement type (nomadic camp)
- Basic population growth at settlement
- Simple UI for viewing unit and placing settlement

**Deliberately Excluded from First Cut:**
- Autonomous AI pathfinding and settlement selection
- Multiple unit types (warriors, scouts, workers)
- Technology-dependent settlement types
- Cultural borders and territory control
- Second settlers unit creation
- Complex tile scoring algorithms
- Movement points and terrain costs

**Success Criteria:**
A successful minimal implementation allows players to:
1. Start a game with 100 population and 1 settlers unit
2. View the map with their settlers unit visible
3. Click a tile on the map to manually place a settlement
4. See the settlement appear and settlers unit disappear
5. Observe population beginning to grow at the new settlement

This minimal design serves as a proof-of-concept for the full settlers system while keeping implementation scope extremely small and focused on validation of core mechanics.

---

## Related Documents

- **0.0007_UNIT_CREATION_AND_BEHAVIOR.md**: Full settlers system design (this is a minimal subset)
- **0.0006_MINIMAL_SIMULATOR.md**: Population simulation and growth mechanics
- **0.0003_MAP_GENERATION.md**: Terrain types and map structure
- **0.0002_GAME_CREATION.md**: Game initialization and player setup

---

## Scope: What's In and What's Out

### In Scope (Minimal Implementation)

**Game Initialization:**
- ✓ Start game with 100 population
- ✓ Create 1 settlers unit at starting position
- ✓ Settlers unit has no settlement (pre-settlement state)

**Unit Display:**
- ✓ Show settlers icon on map at unit's location
- ✓ Display unit information panel when map is hovered/clicked
- ✓ Show current location coordinates

**Manual Settlement:**
- ✓ Click any land tile to attempt settlement
- ✓ Basic validation: tile is land, not ocean
- ✓ Create settlement at clicked tile
- ✓ Remove settlers unit
- ✓ Allocate 100 population to settlement

**Settlement Display:**
- ✓ Show settlement icon on map
- ✓ Display settlement information (location, population, type)

**Population Growth:**
- ✓ Use existing MINIMAL_SIMULATOR mechanics for growth at settlement
- ✓ Population grows from 100 over time

### Out of Scope (Future Implementations)

**Autonomous Behavior:**
- ✗ AI pathfinding and movement
- ✗ Automatic tile scoring
- ✗ Autonomous settlement placement
- ✗ Unit states (searching, moving, settling)

**Multiple Units:**
- ✗ Creating second settlers unit
- ✗ Unit threshold checking (pop 200 → new settlers)
- ✗ Multiple units on map simultaneously
- ✗ Other unit types (warriors, scouts, workers)

**Advanced Features:**
- ✗ Movement points and terrain costs
- ✗ Vision range and fog of war
- ✗ Cultural borders
- ✗ Territory control
- ✗ Technology-dependent settlement types (only nomadic camp)
- ✗ Settlement spacing rules (3-tile minimum)
- ✗ Resource-based tile scoring
- ✗ Multiple settlements per player

**UI Polish:**
- ✗ Hover previews for settlement placement
- ✗ Valid/invalid tile highlighting
- ✗ Animation for settlement creation
- ✗ Notifications and alerts
- ✗ Path visualization
- ✗ Tile score display

---

## Architecture Context

The minimal settlers implementation integrates with SimCiv's existing architecture:

- **Database Layer**: Stores single unit and single settlement per player
- **Simulation Engine**: Uses existing population growth from MINIMAL_SIMULATOR
- **Client Layer**: Adds basic map interaction for settlement placement
- **Game State**: Tracks unit existence and settlement creation

The design maintains the database-as-single-source-of-truth principle while deferring complex logic to future iterations.

---

## Data Model

### Units Collection

```typescript
interface Unit {
  unitId: string;                    // Unique unit identifier
  gameId: string;                    // Game this unit belongs to
  playerId: string;                  // Player who owns this unit
  unitType: "settlers";              // Only settlers in minimal implementation
  
  location: {
    x: number;                       // Current tile X coordinate
    y: number;                       // Current tile Y coordinate
  };
  
  populationCost: 100;               // Fixed at 100 for settlers
  
  createdAt: Date;                   // When unit was created
  lastUpdated: Date;                 // Last state change
}
```

**Simplifications from full design:**
- No `state` field (no AI behavior states)
- No `movement` object (no pathfinding)
- No `searchState` (no autonomous search)
- Only `unitType: "settlers"` supported

### Settlements Collection

```typescript
interface Settlement {
  settlementId: string;              // Unique settlement identifier
  gameId: string;                    // Game this settlement belongs to
  playerId: string;                  // Player who owns this settlement
  name: string;                      // Auto-generated name (e.g., "First Settlement")
  type: "nomadic_camp";              // Only nomadic camp in minimal implementation
  
  location: {
    x: number;                       // Settlement tile X coordinate
    y: number;                       // Settlement tile Y coordinate
  };
  
  population: number;                // Initially 100, grows over time
  
  founded: Date;                     // When settlement was founded
  lastUpdated: Date;                 // Last population/state update
}
```

**Simplifications from full design:**
- No `culturalBorders` (no territory control)
- No `bonuses` (no technology effects)
- No `workingTiles` (no resource system)
- Only `type: "nomadic_camp"` supported

### Game State Extension

Update existing game state to track unit and settlement:

```typescript
interface GamePlayer {
  // ... existing fields (playerId, civilization, startingPosition, etc.)
  
  unitId: string | null;             // ID of player's settlers unit (null after settled)
  settlementId: string | null;       // ID of player's first settlement (null before settled)
  
  // Future: arrays for multiple units/settlements
  // units: string[];
  // settlements: string[];
}
```

---

## Game Initialization

### Starting State

When a game is created with player(s):

**Step 1: Create Initial Units (for each player)**
```typescript
// In game engine initialization, after map generation
for (const player of game.players) {
  // Create initial settlers unit
  const unit = {
    unitId: generateUUID(),
    gameId: game.gameId,
    playerId: player.playerId,
    unitType: "settlers",
    location: player.startingPosition,  // From map generation
    populationCost: 100,
    createdAt: new Date(),
    lastUpdated: new Date()
  };
  
  await db.collection('units').insertOne(unit);
  
  // Update game state to track unit
  player.unitId = unit.unitId;
  player.settlementId = null;
}
```

**Step 2: Initialize Population**
```typescript
// Create population tracking document
for (const player of game.players) {
  const population = {
    gameId: game.gameId,
    playerId: player.playerId,
    totalPopulation: 100,              // Starting population
    allocatedToUnit: 100,              // All pop in settlers unit
    allocatedToSettlement: 0,          // No settlement yet
    unallocated: 0,                    // Nothing unallocated
    lastUpdated: new Date()
  };
  
  await db.collection('population').insertOne(population);
}
```

**Initial Game State Summary:**
- Population: 100 (all in settlers unit)
- Units: 1 settlers unit at starting position
- Settlements: 0 (none yet)
- Player Action Required: Click a tile to place settlement

---

## Manual Settlement Placement

### User Interaction Flow

**Step 1: Map Display**
- Client loads game state from server
- Client retrieves unit for current player
- Client renders settlers icon at unit's location
- Client enables click interaction on all map tiles

**Step 2: Tile Selection**
- User clicks on a map tile
- Client sends settlement request to server with tile coordinates

**Step 3: Server Validation**
```typescript
// POST /api/game/{gameId}/settle
async function handleSettlementRequest(gameId, playerId, tileX, tileY) {
  // 1. Verify player has a settlers unit
  const unit = await db.collection('units').findOne({
    gameId: gameId,
    playerId: playerId,
    unitType: "settlers"
  });
  
  if (!unit) {
    return { error: "No settlers unit available" };
  }
  
  // 2. Verify tile is valid land
  const tile = await db.collection('tiles').findOne({
    gameId: gameId,
    x: tileX,
    y: tileY
  });
  
  if (!tile || tile.terrain === 'OCEAN' || tile.terrain === 'SHALLOW_WATER') {
    return { error: "Cannot settle on water tiles" };
  }
  
  // 3. Create settlement
  const settlement = {
    settlementId: generateUUID(),
    gameId: gameId,
    playerId: playerId,
    name: "First Settlement",       // Auto-generate name
    type: "nomadic_camp",
    location: { x: tileX, y: tileY },
    population: 100,                 // Transfer from unit
    founded: new Date(),
    lastUpdated: new Date()
  };
  
  await db.collection('settlements').insertOne(settlement);
  
  // 4. Remove settlers unit
  await db.collection('units').deleteOne({
    unitId: unit.unitId
  });
  
  // 5. Update game state
  await db.collection('games').updateOne(
    { gameId: gameId, "players.playerId": playerId },
    { 
      $set: { 
        "players.$.unitId": null,
        "players.$.settlementId": settlement.settlementId
      }
    }
  );
  
  // 6. Update population allocation
  await db.collection('population').updateOne(
    { gameId: gameId, playerId: playerId },
    { 
      $set: {
        allocatedToUnit: 0,
        allocatedToSettlement: 100,
        lastUpdated: new Date()
      }
    }
  );
  
  return { success: true, settlement: settlement };
}
```

**Step 4: Client Update**
- Server returns success with settlement data
- Client removes settlers icon from map
- Client adds settlement icon at new location
- Client updates UI to show settlement information

---

## Client Implementation

### Map Rendering

**Minimal Map View Updates:**

```typescript
// In existing map rendering code

// Render units layer (after terrain but before UI)
function renderUnits(ctx, gameState, viewport) {
  const currentPlayer = gameState.currentPlayer;
  
  // Find player's unit
  const unit = gameState.units.find(u => u.playerId === currentPlayer.playerId);
  
  if (unit) {
    const screenPos = worldToScreen(unit.location, viewport);
    
    // Draw simple settlers icon (or use emoji: 🚶)
    ctx.font = '32px Arial';
    ctx.fillText('🚶', screenPos.x - 16, screenPos.y + 16);
    
    // Optional: draw circle around unit for visibility
    ctx.strokeStyle = currentPlayer.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(screenPos.x, screenPos.y, 20, 0, 2 * Math.PI);
    ctx.stroke();
  }
}

// Render settlements layer
function renderSettlements(ctx, gameState, viewport) {
  for (const settlement of gameState.settlements) {
    const screenPos = worldToScreen(settlement.location, viewport);
    
    // Draw settlement icon (or use emoji: ⭐)
    ctx.font = '40px Arial';
    ctx.fillText('⭐', screenPos.x - 20, screenPos.y + 20);
    
    // Draw settlement name
    ctx.font = '12px Arial';
    ctx.fillStyle = 'white';
    ctx.fillText(settlement.name, screenPos.x - 30, screenPos.y + 35);
  }
}
```

### Settlement Placement Interaction

```typescript
// Handle map click for settlement placement
canvas.addEventListener('click', async (event) => {
  const rect = canvas.getBoundingClientRect();
  const clickX = event.clientX - rect.left;
  const clickY = event.clientY - rect.top;
  
  // Convert screen coordinates to world tile coordinates
  const tile = screenToWorld({ x: clickX, y: clickY }, viewport);
  
  // Check if player has a settlers unit
  const hasUnit = gameState.units.some(u => u.playerId === currentPlayer.playerId);
  
  if (!hasUnit) {
    console.log('No settlers unit to place');
    return;
  }
  
  // Send settlement request to server
  const response = await fetch(`/api/game/${gameId}/settle`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      tileX: tile.x,
      tileY: tile.y
    })
  });
  
  const result = await response.json();
  
  if (result.error) {
    console.error('Settlement failed:', result.error);
    // TODO: Show error message to user
  } else {
    console.log('Settlement created:', result.settlement);
    // Reload game state to show new settlement
    await loadGameState();
    render();
  }
});
```

### UI Information Panel

```typescript
// Simple info panel when hovering over unit or settlement
function renderInfoPanel(ctx, entity) {
  if (entity.type === 'unit') {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(10, 10, 200, 80);
    
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`Settlers Unit`, 20, 30);
    ctx.fillText(`Population: 100`, 20, 50);
    ctx.fillText(`Location: (${entity.location.x}, ${entity.location.y})`, 20, 70);
    ctx.font = '12px Arial';
    ctx.fillText(`Click a tile to settle`, 20, 90);
  } else if (entity.type === 'settlement') {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(10, 10, 200, 100);
    
    ctx.fillStyle = 'white';
    ctx.font = '14px Arial';
    ctx.fillText(`${entity.name}`, 20, 30);
    ctx.fillText(`Type: Nomadic Camp`, 20, 50);
    ctx.fillText(`Population: ${entity.population}`, 20, 70);
    ctx.fillText(`Location: (${entity.location.x}, ${entity.location.y})`, 20, 90);
  }
}
```

---

## Server API Endpoints

### New Endpoints for Minimal Implementation

**1. Get Units (for map rendering)**
```
GET /api/game/{gameId}/units
Returns: Array of units for current player

Response:
{
  "units": [
    {
      "unitId": "uuid",
      "unitType": "settlers",
      "location": { "x": 50, "y": 50 },
      "populationCost": 100
    }
  ]
}
```

**2. Get Settlements (for map rendering)**
```
GET /api/game/{gameId}/settlements
Returns: Array of settlements for current player

Response:
{
  "settlements": [
    {
      "settlementId": "uuid",
      "name": "First Settlement",
      "type": "nomadic_camp",
      "location": { "x": 52, "y": 53 },
      "population": 125
    }
  ]
}
```

**3. Place Settlement (manual placement)**
```
POST /api/game/{gameId}/settle
Body: { "tileX": 52, "tileY": 53 }
Returns: Created settlement or error

Response (success):
{
  "success": true,
  "settlement": {
    "settlementId": "uuid",
    "name": "First Settlement",
    "location": { "x": 52, "y": 53 },
    ...
  }
}

Response (error):
{
  "error": "Cannot settle on water tiles"
}
```

---

## Population Growth Integration

### Using Existing MINIMAL_SIMULATOR

The minimal settlers implementation leverages the existing population simulation from 0.0006_MINIMAL_SIMULATOR.md:

**At Each Game Tick:**
```typescript
// In existing game engine tick processing

async function processGameTick(gameId) {
  // ... existing tick logic ...
  
  // For each settlement, run population simulation
  const settlements = await db.collection('settlements').find({ gameId }).toArray();
  
  for (const settlement of settlements) {
    // Use existing human simulation logic
    const popGrowth = await simulatePopulationTick(
      settlement.population,
      settlement.gameId,
      settlement.playerId
    );
    
    // Update settlement population
    await db.collection('settlements').updateOne(
      { settlementId: settlement.settlementId },
      { 
        $set: { 
          population: settlement.population + popGrowth,
          lastUpdated: new Date()
        }
      }
    );
    
    // Update population tracking
    await db.collection('population').updateOne(
      { gameId: gameId, playerId: settlement.playerId },
      {
        $inc: { 
          totalPopulation: popGrowth,
          allocatedToSettlement: popGrowth
        },
        $set: { lastUpdated: new Date() }
      }
    );
  }
}
```

**Key Points:**
- No changes needed to existing MINIMAL_SIMULATOR logic
- Population grows at settlements using existing formulas
- No population growth in settlers units (all growth happens after settling)
- Future implementation will add second settlers threshold check at pop 200

---

## Testing Strategy

### Unit Tests

**Unit Creation:**
- Test game initialization creates settlers unit with correct data
- Test unit has correct starting position
- Test population allocation is correct (100 in unit, 0 in settlement)

**Settlement Validation:**
- Test settlement fails on OCEAN tiles
- Test settlement fails on SHALLOW_WATER tiles
- Test settlement succeeds on GRASSLAND, PLAINS, FOREST, etc.
- Test settlement fails if no settlers unit exists

**Settlement Creation:**
- Test settlement is created with correct location
- Test settlement has correct initial values (type, population, name)
- Test settlers unit is removed after settlement
- Test population is transferred from unit to settlement
- Test game state is updated correctly

**Database Consistency:**
- Test population tracking remains consistent (totalPop = unit + settlement)
- Test unit is properly deleted from database
- Test settlement is properly inserted into database

### Integration Tests

**Complete Settlement Flow:**
1. Start new game
2. Verify initial settlers unit exists at starting position
3. Call settle API with valid tile coordinates
4. Verify settlement is created
5. Verify unit is removed
6. Verify population allocation updated
7. Verify game state updated

**Population Growth at Settlement:**
1. Create settlement
2. Run several game ticks
3. Verify settlement population increases
4. Verify population tracking updated correctly

**Error Handling:**
1. Try to settle without unit (should fail)
2. Try to settle on water (should fail)
3. Try to settle on invalid coordinates (should fail)

### Manual Testing Checklist

**Initial State:**
- [ ] Start new game
- [ ] Verify map loads and displays
- [ ] Verify settlers unit appears at starting position
- [ ] Verify unit icon is visible and correctly positioned

**Settlement Placement:**
- [ ] Click on a land tile (GRASSLAND, PLAINS, etc.)
- [ ] Verify settlement appears at clicked location
- [ ] Verify settlers unit disappears
- [ ] Verify settlement icon is visible

**Population Growth:**
- [ ] Wait for several game ticks (5-10 seconds at 1 tick/sec)
- [ ] Hover over settlement
- [ ] Verify population has increased from initial 100
- [ ] Verify population continues growing over time

**Error Cases:**
- [ ] Try clicking on OCEAN tile (should fail gracefully)
- [ ] After settlement, try clicking another tile (should do nothing)

### E2E Tests (Playwright)

**E2E Test Suite: minimal-settlers.spec.ts**

```typescript
test('Initial settlers unit appears at game start', async ({ page }) => {
  // Create and join game
  await createAndJoinGame(page);
  
  // Wait for map to load
  await page.waitForSelector('canvas');
  
  // Verify settlers unit is visible on map
  // (Check for unit icon or specific game state)
  const gameState = await page.evaluate(() => {
    return window.gameState; // Assuming game state exposed for testing
  });
  
  expect(gameState.units).toHaveLength(1);
  expect(gameState.units[0].unitType).toBe('settlers');
  
  await page.screenshot({ path: 'e2e-screenshots/36-initial-settlers-unit.png' });
});

test('Can place settlement by clicking map tile', async ({ page }) => {
  // Create and join game
  await createAndJoinGame(page);
  
  // Wait for map
  await page.waitForSelector('canvas');
  
  // Click on a land tile to settle
  const canvas = page.locator('canvas');
  await canvas.click({ position: { x: 400, y: 300 } });
  
  // Wait for settlement to be created
  await page.waitForTimeout(1000);
  
  // Verify settlement exists and unit is gone
  const gameState = await page.evaluate(() => window.gameState);
  
  expect(gameState.units).toHaveLength(0);
  expect(gameState.settlements).toHaveLength(1);
  expect(gameState.settlements[0].type).toBe('nomadic_camp');
  expect(gameState.settlements[0].population).toBe(100);
  
  await page.screenshot({ path: 'e2e-screenshots/37-settlement-placed.png' });
});

test('Settlement population grows over time', async ({ page }) => {
  // Create game and place settlement
  await createAndJoinGame(page);
  await page.waitForSelector('canvas');
  const canvas = page.locator('canvas');
  await canvas.click({ position: { x: 400, y: 300 } });
  
  // Get initial population
  await page.waitForTimeout(1000);
  let gameState = await page.evaluate(() => window.gameState);
  const initialPop = gameState.settlements[0].population;
  
  // Wait for population growth (10 seconds = 10 ticks)
  await page.waitForTimeout(10000);
  
  // Get updated population
  gameState = await page.evaluate(() => window.gameState);
  const finalPop = gameState.settlements[0].population;
  
  expect(finalPop).toBeGreaterThan(initialPop);
  
  await page.screenshot({ path: 'e2e-screenshots/38-population-growth.png' });
});

test('Cannot settle on water tiles', async ({ page }) => {
  // Create and join game
  await createAndJoinGame(page);
  await page.waitForSelector('canvas');
  
  // Try to click on an ocean tile
  // This requires knowing where ocean tiles are or using specific test map
  const canvas = page.locator('canvas');
  
  // Attempt to settle on water
  const response = await page.request.post(`/api/game/${gameId}/settle`, {
    data: { tileX: 10, tileY: 10 } // Assume this is water
  });
  
  const result = await response.json();
  expect(result.error).toBeTruthy();
  expect(result.error).toContain('water');
});
```

---

## Implementation Checklist

### Phase 1: Database Schema (1-2 hours)

- [ ] Create `units` collection schema
- [ ] Create `settlements` collection schema
- [ ] Add `unitId` and `settlementId` to game player tracking
- [ ] Add `population` collection for tracking allocations
- [ ] Create database indexes for efficient queries

### Phase 2: Game Initialization (2-3 hours)

- [ ] Modify game creation to initialize settlers unit for each player
- [ ] Set up population tracking (100 pop in unit, 0 in settlement)
- [ ] Verify unit created at player starting position
- [ ] Write unit tests for initialization logic

### Phase 3: Server API (3-4 hours)

- [ ] Implement `GET /api/game/{gameId}/units` endpoint
- [ ] Implement `GET /api/game/{gameId}/settlements` endpoint
- [ ] Implement `POST /api/game/{gameId}/settle` endpoint with validation
- [ ] Write unit tests for settlement validation logic
- [ ] Write integration tests for complete settlement flow

### Phase 4: Client Integration (4-6 hours)

- [ ] Add units to game state loading
- [ ] Render settlers icon on map at unit location
- [ ] Add click handler for tile selection
- [ ] Send settlement request to server on click
- [ ] Handle settlement response (success/error)
- [ ] Render settlement icon on map
- [ ] Add hover info panel for unit and settlement
- [ ] Test in browser with manual testing

### Phase 5: Population Growth Integration (1-2 hours)

- [ ] Modify game tick to process settlement population
- [ ] Use existing MINIMAL_SIMULATOR for growth calculations
- [ ] Update population tracking after each tick
- [ ] Verify population grows correctly over time

### Phase 6: Testing and Polish (3-4 hours)

- [ ] Run all unit tests
- [ ] Run all integration tests
- [ ] Run manual testing checklist
- [ ] Write and run E2E tests
- [ ] Fix any bugs found
- [ ] Take screenshots for documentation

**Total Estimated Time: 14-21 hours**

---

## Success Criteria

### Functional Requirements

**✓ Game Initialization:**
- New game creates 1 settlers unit per player
- Unit appears at correct starting position
- Population tracking initialized correctly

**✓ Settlement Placement:**
- Player can click any land tile to attempt settlement
- Settlement succeeds on land tiles (GRASSLAND, PLAINS, FOREST, etc.)
- Settlement fails on water tiles (OCEAN, SHALLOW_WATER)
- Settlement is created with correct data

**✓ State Updates:**
- Settlers unit is removed after settlement
- Settlement appears on map
- Population allocated correctly (from unit to settlement)
- Game state reflects changes

**✓ Population Growth:**
- Settlement population grows over time using existing mechanics
- Population tracking updated correctly
- Growth rate matches MINIMAL_SIMULATOR expectations

### Technical Requirements

**✓ Database Consistency:**
- No duplicate units or settlements
- Population tracking always consistent
- All foreign keys valid (gameId, playerId, etc.)

**✓ API Correctness:**
- All endpoints return proper status codes
- Error messages are clear and helpful
- Request validation prevents invalid states

**✓ UI Functionality:**
- Map renders units and settlements correctly
- Click interaction works reliably
- Info panel displays current state accurately

**✓ Test Coverage:**
- All unit tests pass
- All integration tests pass
- All E2E tests pass
- Manual testing checklist complete

---

## Future Enhancements (Not in Minimal Implementation)

After the minimal implementation is validated, future iterations can add:

**Phase 2: Autonomous Settlement (from version 0.0007)**
- AI pathfinding and movement
- Tile scoring algorithm
- Autonomous settlement selection
- Unit states (searching, moving, settling)

**Phase 3: Multiple Units**
- Second settlers creation at pop 200
- Multiple units on map simultaneously
- Unit threshold checking and notifications

**Phase 4: Advanced Features**
- Technology-dependent settlement types
- Cultural borders and territory
- Settlement spacing rules
- Multiple settlements per player
- Movement points and terrain costs

**Phase 5: Other Unit Types**
- Warriors for defense
- Scouts for exploration
- Workers for improvements

---

## Dependencies and Prerequisites

**Existing Systems Required:**
- Game creation and initialization (version 0.0002)
- Map generation with terrain types (version 0.0003)
- Population simulation mechanics (version 0.0006)
- Client map rendering with canvas

**Database:**
- MongoDB collections for units and settlements
- Existing collections: games, tiles, players, population

**Client:**
- Canvas-based map rendering
- Basic click interaction handlers
- API communication layer

**Server:**
- Express API endpoints
- Database connection and queries
- Game tick processing loop

---

## Open Questions for Implementation

1. **Unit Icon:** Use emoji (🚶) or create custom SVG sprite?
2. **Settlement Icon:** Use emoji (⭐) or create custom icon?
3. **Auto-naming:** Use "First Settlement" or generate names like "Settlement 1"?
4. **Error Feedback:** Console log, alert dialog, or inline UI message?
5. **Click Confirmation:** Click once to settle, or click then confirm button?
6. **Info Panel:** Always visible, or only on hover?
7. **Population Display:** Show exact number, or rounded/formatted?
8. **Map Zoom:** Handle unit/settlement rendering at different zoom levels?

---

## Conclusion

This minimal settlers implementation provides the **absolute minimum** functionality needed to validate the core mechanics of the population-based expansion system. By deliberately excluding AI, multiple units, and advanced features, the implementation remains small, focused, and achievable in a short timeframe.

The success of this minimal implementation will validate:
- Population threshold mechanics (100 pop → 1 settlers)
- Manual settlement placement workflow
- Population growth at settlements
- Database structure and API design
- Client rendering and interaction

Once validated, this foundation enables confident implementation of the full autonomous settlers system described in version 0.0007, with the knowledge that the core mechanics are sound and the architecture supports the required functionality.

This minimal-first approach follows software engineering best practices: **build the simplest thing that could possibly work, validate it, then iterate toward the full design**.
